---
phase: 05-pattern-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/hooks.json
  - scripts/cleanup-session.sh
autonomous: true
requirements:
  - EXTR-01
  - EXTR-03

must_haves:
  truths:
    - "Stop hook with type agent is registered in hooks.json"
    - "Agent hook prompt references extract-patterns.md via ${CLAUDE_PLUGIN_ROOT} path with fallback resolution and inline minimal instructions for cwd-vs-plugin-root mismatch, and includes $ARGUMENTS"
    - "Agent hook has timeout of 120 seconds and a statusMessage"
    - "cleanup-session.sh archives session log to .prev before truncating"
    - "hooks.json remains valid JSON with all existing hooks preserved"
  artifacts:
    - path: "hooks/hooks.json"
      provides: "Stop agent hook registration"
      contains: "Stop"
    - path: "scripts/cleanup-session.sh"
      provides: "Session log archive safety net"
      contains: ".prev"
  key_links:
    - from: "hooks/hooks.json"
      to: "agents/extract-patterns.md"
      via: "Stop agent hook prompt uses ${CLAUDE_PLUGIN_ROOT}/agents/extract-patterns.md with fallback path resolution"
      pattern: "extract-patterns"
    - from: "scripts/cleanup-session.sh"
      to: ".auto-context/session-log.jsonl.prev"
      via: "cp before truncate"
      pattern: "\\.prev"
---

<objective>
Register the Stop agent hook in hooks.json and add session log archive safety in cleanup-session.sh. This wires the extraction agent (from Plan 01) into the Claude Code hook lifecycle and prevents the SessionEnd race condition from losing session data.

Purpose: Without hook registration, the extraction agent prompt has no trigger. Without the archive safety net, the SessionEnd cleanup could destroy log data needed by the extraction agent in edge cases.
Output: Updated hooks/hooks.json with Stop agent hook, updated scripts/cleanup-session.sh with archive-before-truncate.
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pattern-extraction/05-RESEARCH.md
@hooks/hooks.json
@scripts/cleanup-session.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Stop agent hook in hooks.json</name>
  <files>hooks/hooks.json</files>
  <action>
Add a `Stop` event entry to `hooks/hooks.json` between `PostToolUseFailure` and `SessionEnd` (logical lifecycle ordering).

Use the simpler single-agent-hook approach (per research recommendation for v1). The agent prompt in hooks.json should be concise -- it tells the agent to:
1. Check stop_hook_active from hook input
2. Read the full instructions from the agents/extract-patterns.md file
3. Follow those instructions to analyze the session

**Path resolution strategy for agents/extract-patterns.md (addressing cwd-vs-plugin-root mismatch):**

The `agents/extract-patterns.md` file lives inside the auto-context plugin directory, NOT in the user's project directory. The `cwd` from hook input points to the user's project (e.g., `/Users/alice/my-app`). The existing command hooks in hooks.json all use `${CLAUDE_PLUGIN_ROOT}` for path resolution (see SessionStart, PostToolUse, etc.), but for agent hooks the prompt is sent to the LLM -- not executed as a shell command -- so `${CLAUDE_PLUGIN_ROOT}` may not expand.

**Approach: Use `${CLAUDE_PLUGIN_ROOT}` with inline fallback.**

1. The prompt uses `${CLAUDE_PLUGIN_ROOT}/agents/extract-patterns.md` as the primary path. If Claude Code expands env vars in agent hook prompts (as it does for command hooks), this resolves correctly.
2. The prompt includes a fallback instruction: if the Read tool fails on that path, the agent should attempt to locate the plugin by searching for the auto-context hooks.json file in common locations (`node_modules/.hooks/auto-context/`, `.claude/plugins/auto-context/`, or by reading `.claude/settings.json` to find the plugin root).
3. As a last resort, the prompt includes enough inline context (the essential pre-check, classification categories, and output format) so the agent can perform basic extraction even without the full instructions file.

Hook entry to add:

```json
"Stop": [
  {
    "hooks": [
      {
        "type": "agent",
        "prompt": "You are the auto-context pattern extraction agent.\n\nFirst, parse the hook input below. If stop_hook_active is true, respond immediately with {\"ok\": true} and do nothing else.\n\nOtherwise, use the Read tool to load the full instructions file at: ${CLAUDE_PLUGIN_ROOT}/agents/extract-patterns.md\n\nIf that path fails (file not found), try these fallback paths to locate the plugin root:\n1. Read .claude/settings.json in the project cwd and look for the auto-context plugin path\n2. Search for agents/extract-patterns.md in common plugin locations\n\nIf you cannot find the instructions file at all, perform minimal extraction: read .auto-context/session-log.jsonl in the project cwd, identify intentional coding patterns (consistent across 2+ files, not framework-imposed), and write them to .auto-context/candidates.json with classification=intentional, confidence=0.3, source=extraction, and at least 2 evidence citations per pattern. Always respond with {\"ok\": true}.\n\nHook input: $ARGUMENTS",
        "timeout": 120,
        "statusMessage": "Auto-Context: analyzing session for patterns..."
      }
    ]
  }
]
```

**Critical constraints:**
- Preserve ALL existing hook entries (SessionStart, UserPromptSubmit, PostToolUse, PostToolUseFailure, SessionEnd)
- The prompt uses `$ARGUMENTS` placeholder (expanded by Claude Code at runtime with the Stop event JSON)
- The prompt uses `${CLAUDE_PLUGIN_ROOT}` for the primary path (consistent with how all other hooks reference plugin files). Whether this expands in agent hook prompts is uncertain (research open question #4), so the prompt includes fallback resolution and inline minimal instructions.
- Timeout: 120 seconds (research recommendation -- gives agent time for multi-file Read/Grep operations)
- statusMessage provides user feedback during extraction

Validate the resulting hooks.json is valid JSON with `jq .`.
  </action>
  <verify>
    <automated>jq '.hooks.Stop[0].hooks[0].type' hooks/hooks.json | grep -q 'agent' && jq '.hooks.Stop[0].hooks[0].timeout' hooks/hooks.json | grep -q '120' && jq '.hooks | keys | length' hooks/hooks.json | grep -q '6' && echo "PASS"</automated>
    <manual>Verify hooks.json has 6 event types: SessionStart, UserPromptSubmit, PostToolUse, PostToolUseFailure, Stop, SessionEnd. Stop entry has type=agent, timeout=120, statusMessage present, prompt includes $ARGUMENTS. Prompt uses ${CLAUDE_PLUGIN_ROOT}/agents/extract-patterns.md as primary path, includes fallback path resolution instructions, and has inline minimal extraction instructions as last resort.</manual>
  </verify>
  <done>hooks.json contains a Stop agent hook entry with type=agent, timeout=120, statusMessage, and a prompt that references extract-patterns.md via Read tool using ${CLAUDE_PLUGIN_ROOT} as primary path. Prompt includes fallback path resolution and inline minimal extraction instructions for the case where the instructions file cannot be found (cwd-vs-plugin-root mismatch handled). All 5 existing hooks preserved. File is valid JSON.</done>
</task>

<task type="auto">
  <name>Task 2: Add session log archive safety to cleanup-session.sh</name>
  <files>scripts/cleanup-session.sh</files>
  <action>
Modify `scripts/cleanup-session.sh` to archive the session log before truncating. This is a safety net for the race condition between the Stop agent hook (which reads the session log) and the SessionEnd handler (which truncates it).

**Current behavior:** Truncates session-log.jsonl unconditionally with `: >`.

**New behavior:** Copy session-log.jsonl to session-log.jsonl.prev before truncating. The `.prev` file serves as a backup in case the extraction agent hasn't finished (edge case: user exits immediately after Claude's last response).

Changes to make:
1. Before the `: > "$LOG_FILE"` line, add: `cp "$LOG_FILE" "${LOG_FILE}.prev" 2>/dev/null || true`
2. The `|| true` ensures the script doesn't fail if cp fails for any reason
3. Add the `-s` flag to the existing `-f` check: `if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]` -- only archive if file exists AND has content (don't create empty .prev files)
4. Keep the existing `: > "$LOG_FILE"` truncation as-is

The resulting script should be approximately:
```bash
#!/usr/bin/env bash
set -euo pipefail

INPUT=$(cat)
CWD=$(echo "$INPUT" | jq -r '.cwd')

LOG_FILE="${CWD}/.auto-context/session-log.jsonl"

if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]; then
  # Archive for Stop hook extraction safety (Phase 5)
  cp "$LOG_FILE" "${LOG_FILE}.prev" 2>/dev/null || true
  : > "$LOG_FILE"
fi

exit 0
```

Note: The `.prev` file will be cleaned up by the next SessionStart (Phase 6 can add this, or it can accumulate harmlessly -- one session's worth of JSONL is tiny).
  </action>
  <verify>
    <automated>bash -n scripts/cleanup-session.sh && grep -q '\.prev' scripts/cleanup-session.sh && grep -q 'cp ' scripts/cleanup-session.sh && echo "PASS"</automated>
    <manual>Verify cleanup-session.sh copies session log to .prev before truncating, uses || true for safety, and checks -s (non-empty) before archiving.</manual>
  </verify>
  <done>cleanup-session.sh archives session-log.jsonl to session-log.jsonl.prev before truncating. Archive only happens if file exists and has content. Copy failure is silently ignored (|| true). Script passes bash -n syntax check.</done>
</task>

</tasks>

<verification>
- `jq . hooks/hooks.json` validates (valid JSON)
- hooks.json has 6 event types: SessionStart, UserPromptSubmit, PostToolUse, PostToolUseFailure, Stop, SessionEnd
- Stop hook entry: type=agent, timeout=120, prompt includes $ARGUMENTS and extract-patterns.md reference
- `bash -n scripts/cleanup-session.sh` passes (valid bash)
- cleanup-session.sh contains cp to .prev before truncate
- All existing hooks preserved (no regressions to Phases 1-4)
</verification>

<success_criteria>
The Stop agent hook is registered in hooks.json and will fire the extraction agent on every Claude response. The session log is archived before cleanup as a race condition safety net. Both files validate syntactically and preserve all existing functionality.
</success_criteria>

<output>
After completion, create `.planning/phases/05-pattern-extraction/05-02-SUMMARY.md`
</output>
