---
phase: 05-pattern-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/hooks.json
  - scripts/cleanup-session.sh
autonomous: true
requirements:
  - EXTR-01
  - EXTR-03

must_haves:
  truths:
    - "Stop hook with type agent is registered in hooks.json"
    - "Agent hook prompt references extract-patterns.md instructions and includes $ARGUMENTS"
    - "Agent hook has timeout of 120 seconds and a statusMessage"
    - "cleanup-session.sh archives session log to .prev before truncating"
    - "hooks.json remains valid JSON with all existing hooks preserved"
  artifacts:
    - path: "hooks/hooks.json"
      provides: "Stop agent hook registration"
      contains: "Stop"
    - path: "scripts/cleanup-session.sh"
      provides: "Session log archive safety net"
      contains: ".prev"
  key_links:
    - from: "hooks/hooks.json"
      to: "agents/extract-patterns.md"
      via: "Stop agent hook prompt instruction"
      pattern: "extract-patterns"
    - from: "scripts/cleanup-session.sh"
      to: ".auto-context/session-log.jsonl.prev"
      via: "cp before truncate"
      pattern: "\\.prev"
---

<objective>
Register the Stop agent hook in hooks.json and add session log archive safety in cleanup-session.sh. This wires the extraction agent (from Plan 01) into the Claude Code hook lifecycle and prevents the SessionEnd race condition from losing session data.

Purpose: Without hook registration, the extraction agent prompt has no trigger. Without the archive safety net, the SessionEnd cleanup could destroy log data needed by the extraction agent in edge cases.
Output: Updated hooks/hooks.json with Stop agent hook, updated scripts/cleanup-session.sh with archive-before-truncate.
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pattern-extraction/05-RESEARCH.md
@hooks/hooks.json
@scripts/cleanup-session.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Stop agent hook in hooks.json</name>
  <files>hooks/hooks.json</files>
  <action>
Add a `Stop` event entry to `hooks/hooks.json` between `PostToolUseFailure` and `SessionEnd` (logical lifecycle ordering).

Use the simpler single-agent-hook approach (per research recommendation for v1). The agent prompt in hooks.json should be concise -- it tells the agent to:
1. Check stop_hook_active from hook input
2. Read the full instructions from the agents/extract-patterns.md file
3. Follow those instructions to analyze the session

Hook entry to add:

```json
"Stop": [
  {
    "hooks": [
      {
        "type": "agent",
        "prompt": "You are the auto-context pattern extraction agent. First, parse the hook input below. If stop_hook_active is true, respond immediately with {\"ok\": true} and do nothing else. Otherwise, use the Read tool to load the instructions file at agents/extract-patterns.md in the project working directory, then follow those instructions completely.\n\nHook input: $ARGUMENTS",
        "timeout": 120,
        "statusMessage": "Auto-Context: analyzing session for patterns..."
      }
    ]
  }
]
```

**Critical constraints:**
- Preserve ALL existing hook entries (SessionStart, UserPromptSubmit, PostToolUse, PostToolUseFailure, SessionEnd)
- The prompt uses `$ARGUMENTS` placeholder (expanded by Claude Code at runtime with the Stop event JSON)
- The prompt does NOT use `${CLAUDE_PLUGIN_ROOT}` because environment variable expansion may not work in agent hook prompts (per research open question #4). Instead, the agent reads the file relative to cwd.
- Timeout: 120 seconds (research recommendation -- gives agent time for multi-file Read/Grep operations)
- statusMessage provides user feedback during extraction

Validate the resulting hooks.json is valid JSON with `jq .`.
  </action>
  <verify>
    <automated>jq '.hooks.Stop[0].hooks[0].type' hooks/hooks.json | grep -q 'agent' && jq '.hooks.Stop[0].hooks[0].timeout' hooks/hooks.json | grep -q '120' && jq '.hooks | keys | length' hooks/hooks.json | grep -q '6' && echo "PASS"</automated>
    <manual>Verify hooks.json has 6 event types: SessionStart, UserPromptSubmit, PostToolUse, PostToolUseFailure, Stop, SessionEnd. Stop entry has type=agent, timeout=120, statusMessage present, prompt includes $ARGUMENTS.</manual>
  </verify>
  <done>hooks.json contains a Stop agent hook entry with type=agent, timeout=120, statusMessage, and a concise prompt that references extract-patterns.md via Read tool. All 5 existing hooks preserved. File is valid JSON.</done>
</task>

<task type="auto">
  <name>Task 2: Add session log archive safety to cleanup-session.sh</name>
  <files>scripts/cleanup-session.sh</files>
  <action>
Modify `scripts/cleanup-session.sh` to archive the session log before truncating. This is a safety net for the race condition between the Stop agent hook (which reads the session log) and the SessionEnd handler (which truncates it).

**Current behavior:** Truncates session-log.jsonl unconditionally with `: >`.

**New behavior:** Copy session-log.jsonl to session-log.jsonl.prev before truncating. The `.prev` file serves as a backup in case the extraction agent hasn't finished (edge case: user exits immediately after Claude's last response).

Changes to make:
1. Before the `: > "$LOG_FILE"` line, add: `cp "$LOG_FILE" "${LOG_FILE}.prev" 2>/dev/null || true`
2. The `|| true` ensures the script doesn't fail if cp fails for any reason
3. Add the `-s` flag to the existing `-f` check: `if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]` -- only archive if file exists AND has content (don't create empty .prev files)
4. Keep the existing `: > "$LOG_FILE"` truncation as-is

The resulting script should be approximately:
```bash
#!/usr/bin/env bash
set -euo pipefail

INPUT=$(cat)
CWD=$(echo "$INPUT" | jq -r '.cwd')

LOG_FILE="${CWD}/.auto-context/session-log.jsonl"

if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]; then
  # Archive for Stop hook extraction safety (Phase 5)
  cp "$LOG_FILE" "${LOG_FILE}.prev" 2>/dev/null || true
  : > "$LOG_FILE"
fi

exit 0
```

Note: The `.prev` file will be cleaned up by the next SessionStart (Phase 6 can add this, or it can accumulate harmlessly -- one session's worth of JSONL is tiny).
  </action>
  <verify>
    <automated>bash -n scripts/cleanup-session.sh && grep -q '\.prev' scripts/cleanup-session.sh && grep -q 'cp ' scripts/cleanup-session.sh && echo "PASS"</automated>
    <manual>Verify cleanup-session.sh copies session log to .prev before truncating, uses || true for safety, and checks -s (non-empty) before archiving.</manual>
  </verify>
  <done>cleanup-session.sh archives session-log.jsonl to session-log.jsonl.prev before truncating. Archive only happens if file exists and has content. Copy failure is silently ignored (|| true). Script passes bash -n syntax check.</done>
</task>

</tasks>

<verification>
- `jq . hooks/hooks.json` validates (valid JSON)
- hooks.json has 6 event types: SessionStart, UserPromptSubmit, PostToolUse, PostToolUseFailure, Stop, SessionEnd
- Stop hook entry: type=agent, timeout=120, prompt includes $ARGUMENTS and extract-patterns.md reference
- `bash -n scripts/cleanup-session.sh` passes (valid bash)
- cleanup-session.sh contains cp to .prev before truncate
- All existing hooks preserved (no regressions to Phases 1-4)
</verification>

<success_criteria>
The Stop agent hook is registered in hooks.json and will fire the extraction agent on every Claude response. The session log is archived before cleanup as a race condition safety net. Both files validate syntactically and preserve all existing functionality.
</success_criteria>

<output>
After completion, create `.planning/phases/05-pattern-extraction/05-02-SUMMARY.md`
</output>
