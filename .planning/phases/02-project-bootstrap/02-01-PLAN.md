---
phase: 02-project-bootstrap
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/ac-init/scripts/discover-commands.sh
  - skills/ac-init/SKILL.md
autonomous: true
requirements: [BOOT-01, BOOT-02, BOOT-03]

must_haves:
  truths:
    - "/ac-init skill exists and Claude can follow its scanning instructions"
    - "discover-commands.sh extracts build/test/lint commands from package.json, Makefile, pyproject.toml, and Cargo.toml"
    - "SKILL.md instructs Claude to scan structure, config, git history, source code, then synthesize conventions"
    - "Scanning instructions go deeper than /init (naming conventions, testing patterns, architecture patterns, error handling)"
  artifacts:
    - path: "skills/ac-init/SKILL.md"
      provides: "Multi-step project scanning instructions for Claude"
      contains: "name: ac-init"
      min_lines: 100
    - path: "skills/ac-init/scripts/discover-commands.sh"
      provides: "Deterministic build/test/lint command extraction"
      min_lines: 40
  key_links:
    - from: "skills/ac-init/SKILL.md"
      to: "skills/ac-init/scripts/discover-commands.sh"
      via: "bash ${CLAUDE_PLUGIN_ROOT}/skills/ac-init/scripts/discover-commands.sh"
      pattern: "discover-commands\\.sh"
    - from: "skills/ac-init/SKILL.md"
      to: ".auto-context/conventions.json"
      via: "Write conventions to conventions.json"
      pattern: "conventions\\.json"
    - from: "skills/ac-init/SKILL.md"
      to: "scripts/inject-context.sh"
      via: "Trigger injection pipeline after convention generation"
      pattern: "inject-context\\.sh"
---

<objective>
Create the /auto-context:ac-init skill that bootstraps project context by scanning structure, tech stack, config files, and git history to generate initial conventions that surpass Claude Code's built-in /init.

Purpose: This is the flagship bootstrap command. When users run /auto-context:ac-init, Claude performs a deep multi-step project analysis and generates actionable conventions written to .auto-context/conventions.json, then triggers CLAUDE.md injection via the existing Phase 1 pipeline.

Output: skills/ac-init/SKILL.md (scanning instructions) + skills/ac-init/scripts/discover-commands.sh (deterministic command extraction)
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-project-bootstrap/02-RESEARCH.md
@.planning/phases/01-plugin-skeleton-injection/01-01-SUMMARY.md
@.planning/phases/01-plugin-skeleton-injection/01-02-SUMMARY.md
@scripts/inject-context.sh
@scripts/lib/markers.sh
@scripts/lib/tokens.sh
@hooks/hooks.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create discover-commands.sh for deterministic build/test/lint extraction</name>
  <files>skills/ac-init/scripts/discover-commands.sh</files>
  <action>
Create `skills/ac-init/scripts/` directory and write `discover-commands.sh`. This script deterministically extracts build/test/lint commands from config files using jq/grep/awk (no Claude reasoning needed for this part). The script must:

1. Accept optional `CWD` argument (default: `.`)
2. Output a single JSON object to stdout with discovered commands
3. Handle four config formats:

**package.json** (via jq):
- Extract ALL scripts as key:value pairs
- Categorize into build, test, lint, dev groups using key name patterns:
  - build: keys matching `^(build|compile|bundle)`
  - test: keys matching `^(test|spec|e2e|cypress)`
  - lint: keys matching `^(lint|format|prettier|eslint|check|typecheck)`
  - dev: keys matching `^(dev|start|serve)`
- Also extract `packageManager` field if present
- Also extract `type` field (module vs commonjs)

**Makefile** (via grep/awk):
- Extract non-hidden targets: `grep -E '^[a-zA-Z_][a-zA-Z0-9_-]*:' Makefile | grep -v -E '^\.' | sed 's/:.*//' | head -30`
- Output as `makefile_targets` array

**pyproject.toml** (via grep/awk):
- Detect presence of `[tool.pytest]`, `[tool.ruff]`, `[tool.mypy]`, `[tool.black]`, `[tool.poetry.scripts]`
- Extract `[project.scripts]` entries if present
- Output as `pyproject_tools` array

**Cargo.toml** (via grep):
- Detect workspace vs single crate
- Extract `[package]` name
- Detect `[dev-dependencies]` for test frameworks
- Output as `cargo_info` object

Output format example:
```json
{
  "package_json": {
    "scripts": {"build": "tsc", "test": "vitest", "lint": "eslint ."},
    "package_manager": "pnpm",
    "module_type": "module"
  },
  "makefile_targets": ["build", "test", "lint", "clean"],
  "pyproject_tools": ["pytest", "ruff"],
  "cargo_info": null
}
```

Use `set -euo pipefail`. Exit 0 always (missing config files are normal, not errors). Follow Phase 1 patterns: use jq for JSON, grep -F where possible, handle macOS awk/grep quirks. Make the script executable with `chmod +x`.
  </action>
  <verify>
    <automated>bash skills/ac-init/scripts/discover-commands.sh . | jq '.' && echo "PASS: valid JSON output"</automated>
    <manual>Verify the script handles missing config files gracefully (no errors when Makefile/Cargo.toml absent)</manual>
  </verify>
  <done>discover-commands.sh outputs valid JSON with extracted commands from whichever config files exist in the project. Missing config files produce null/empty values, not errors. Script exits 0 in all cases.</done>
</task>

<task type="auto">
  <name>Task 2: Create ac-init SKILL.md with multi-step scanning instructions</name>
  <files>skills/ac-init/SKILL.md</files>
  <action>
Create `skills/ac-init/SKILL.md` with YAML frontmatter and detailed multi-step scanning instructions for Claude. This is the core of Phase 2: the instructions that guide Claude to perform deep project analysis.

**Frontmatter:**
```yaml
---
name: ac-init
description: Bootstrap project context by scanning structure, tech stack, config files, and git history. Generates initial conventions that surpass Claude Code's built-in /init. Use when setting up auto-context for a new project.
disable-model-invocation: true
---
```

Key frontmatter decisions per research:
- `disable-model-invocation: true` -- user must explicitly invoke, not auto-triggered
- No `context: fork` -- runs inline so Claude can write to project files
- No `allowed-tools` restriction -- Claude needs Read, Glob, Grep, Bash, Write

**SKILL.md body instructions (7 steps):**

**Step 1: Initialize Data Store**
- Ensure `.auto-context/` directory exists with required JSON files (conventions.json, candidates.json, anti-patterns.json, config.json, session-log.jsonl)
- Check for existing conventions. If conventions exist with non-bootstrap sources, warn user and ask whether to merge or replace.
- If conventions.json has entries with `"source": "bootstrap"`, those will be replaced. Non-bootstrap conventions are preserved.

**Step 2: Detect Project Type and Structure**
- Use Glob to find indicator files for package managers/languages: package.json, pyproject.toml, Cargo.toml, go.mod, Gemfile, pom.xml, build.gradle
- Use Glob for framework config files: next.config.*, vite.config.*, astro.config.*, nuxt.config.*, angular.json, svelte.config.*
- Use Glob for tooling config: tsconfig.json, .eslintrc*, eslint.config.*, .prettierrc*, prettier.config.*, jest.config.*, vitest.config.*, pytest.ini, Makefile, Dockerfile, docker-compose.*, .github/workflows/
- Read each detected config file to extract specific settings (TypeScript strict mode, ESLint rules, test framework config, etc.)
- Determine primary language, framework, and package manager

**Step 3: Discover Build/Test/Lint Commands**
- Run the bundled discovery script: `bash ${CLAUDE_PLUGIN_ROOT}/skills/ac-init/scripts/discover-commands.sh .`
- Interpret the JSON output to identify build, test, lint, and dev commands
- For each command, note the full invocation (e.g., `npm run test`, `make lint`, `cargo test`)
- Identify single-file test execution pattern if possible (e.g., `npx vitest run path/to/file`)

**Step 4: Analyze Git History**
- If git repository: run `git log --oneline -20`, `git shortlog -sn --no-merges HEAD~100..HEAD 2>/dev/null`, `git diff-tree --no-commit-id --name-only -r HEAD~10..HEAD 2>/dev/null`
- Detect commit message conventions (conventional commits, etc.)
- Identify active areas of the codebase from recent changes
- Note contribution patterns (solo vs team)

**Step 5: Sample Source Code for Conventions**
- Read 3-5 source files from the most active areas (identified in Step 4) or entry points
- Detect: naming conventions (camelCase vs snake_case vs PascalCase), import style (relative vs absolute, barrel files), error handling patterns (try/catch style, Result types, error boundaries), comment style, module organization
- Cap file reads: first 100 lines per file, max 5 files sampled
- This is where /ac-init surpasses /init: detecting patterns Claude Code's built-in /init does not examine

**Step 6: Synthesize Conventions**
- Combine all findings into conventions array
- Each convention must be: specific and actionable, evidenced by files examined, scored with confidence 0.6-0.9 (bootstrap range)
- Convention format: `{"text": "...", "confidence": N, "source": "bootstrap", "created_at": "ISO timestamp", "observed_in": ["file1", "file2"]}`
- Categories to generate conventions for:
  - Tech stack and framework (e.g., "Uses Next.js 14 with App Router")
  - Build/test/lint commands (e.g., "Run tests with: npm run test")
  - Code style (e.g., "Uses camelCase for variables, PascalCase for components")
  - Architecture patterns (e.g., "Feature-sliced directory structure under src/features/")
  - Testing patterns (e.g., "Tests use Vitest with .test.ts extension")
  - Error handling (e.g., "API errors return {error: string} JSON responses")
- Merge with existing non-bootstrap conventions if present
- Write to `.auto-context/conventions.json`

**Step 7: Trigger CLAUDE.md Update**
- Call the existing injection pipeline: `echo '{"cwd":"'$(pwd)'","session_id":"ac-init"}' | bash ${CLAUDE_PLUGIN_ROOT}/scripts/inject-context.sh`
- Report to user: how many conventions were generated, what categories were detected, remind them conventions will be injected on each session start
- If injection fails, still keep conventions.json (injection will happen at next SessionStart)

**Important notes to include in the skill:**
- Do NOT read every file. Focus on config files, entry points, and a small sample of source files.
- Do NOT hard-code framework detection. Use config file presence (glob patterns) and let your reasoning handle identification.
- Write to conventions.json, NOT directly to CLAUDE.md. The injection pipeline handles CLAUDE.md.
- If re-running on existing project: preserve non-bootstrap conventions, replace bootstrap ones.

Keep SKILL.md under 400 lines per research recommendation (official guidance says under 500). The power comes from Claude's reasoning, not exhaustive instructions.
  </action>
  <verify>
    <automated>test -f skills/ac-init/SKILL.md && head -5 skills/ac-init/SKILL.md | grep -q "name: ac-init" && wc -l skills/ac-init/SKILL.md | awk '{if ($1 > 50 && $1 < 500) print "PASS: reasonable length ("$1" lines)"; else print "FAIL: unexpected length ("$1" lines)"}'</automated>
    <manual>Read through SKILL.md and verify all 7 steps are present, instructions are specific enough for Claude to follow without interpretation, and the scanning goes deeper than built-in /init</manual>
  </verify>
  <done>SKILL.md exists with valid frontmatter (name: ac-init, disable-model-invocation: true), contains 7 scanning steps covering structure detection, command discovery, git analysis, source sampling, and convention synthesis. References discover-commands.sh correctly via CLAUDE_PLUGIN_ROOT. Instructs writing to conventions.json and triggering injection pipeline. Under 500 lines.</done>
</task>

</tasks>

<verification>
1. `skills/ac-init/SKILL.md` exists with valid YAML frontmatter
2. `skills/ac-init/scripts/discover-commands.sh` is executable and produces valid JSON
3. SKILL.md references discover-commands.sh via `${CLAUDE_PLUGIN_ROOT}/skills/ac-init/scripts/discover-commands.sh`
4. SKILL.md references conventions.json for output (not direct CLAUDE.md writes)
5. SKILL.md references `${CLAUDE_PLUGIN_ROOT}/scripts/inject-context.sh` for triggering injection
6. discover-commands.sh handles all four config formats (package.json, Makefile, pyproject.toml, Cargo.toml)
7. discover-commands.sh exits 0 even when config files are missing
</verification>

<success_criteria>
- /auto-context:ac-init skill is fully defined with scanning instructions that guide Claude through project analysis
- Bundled discover-commands.sh deterministically extracts build/test/lint commands from all supported config formats
- Scanning instructions explicitly target patterns that /init misses: naming conventions, testing patterns, architecture patterns, error handling, import style
- Convention output format matches Phase 1 conventions.json schema ({text, confidence, source, created_at, observed_in})
- Skill integrates with Phase 1 injection pipeline (writes conventions.json, calls inject-context.sh)
</success_criteria>

<output>
After completion, create `.planning/phases/02-project-bootstrap/02-01-SUMMARY.md`
</output>
