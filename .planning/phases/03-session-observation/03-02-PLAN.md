---
phase: 03-session-observation
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - scripts/cleanup-session.sh
  - scripts/inject-context.sh
  - hooks/hooks.json
autonomous: true
requirements:
  - OBSV-05

must_haves:
  truths:
    - "SessionEnd hook clears session-log.jsonl so logs never accumulate across sessions"
    - "SessionStart handles stale logs from crashed sessions (safety net)"
    - "cleanup-session.sh executes in under 100ms"
  artifacts:
    - path: "scripts/cleanup-session.sh"
      provides: "SessionEnd log rotation handler"
      contains: "session-log.jsonl"
    - path: "hooks/hooks.json"
      provides: "Complete hook configuration with SessionStart, PostToolUse, PostToolUseFailure, and SessionEnd"
      contains: "SessionEnd"
    - path: "scripts/inject-context.sh"
      provides: "Stale session log cleanup safety net at SessionStart"
      contains: "session-log"
  key_links:
    - from: "hooks/hooks.json"
      to: "scripts/cleanup-session.sh"
      via: "SessionEnd command hook reference"
      pattern: "cleanup-session\\.sh"
    - from: "scripts/cleanup-session.sh"
      to: ".auto-context/session-log.jsonl"
      via: "truncation on session end"
      pattern: "> .*session-log\\.jsonl"
    - from: "scripts/inject-context.sh"
      to: ".auto-context/session-log.jsonl"
      via: "stale log detection at session start"
      pattern: "session-log\\.jsonl"
---

<objective>
Implement session log rotation at SessionEnd and a stale-log safety net at SessionStart, ensuring observation data never accumulates across sessions.

Purpose: Without rotation, session-log.jsonl would grow unbounded across sessions. The SessionEnd hook provides the clean lifecycle boundary. The SessionStart safety net handles cases where SessionEnd did not fire (process kill, crash).

Output: `scripts/cleanup-session.sh` (executable), updated `hooks/hooks.json` with SessionEnd entry, updated `scripts/inject-context.sh` with stale log detection.
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-session-observation/03-RESEARCH.md
@.planning/phases/03-session-observation/03-01-SUMMARY.md
@hooks/hooks.json
@scripts/inject-context.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cleanup-session.sh and register SessionEnd hook</name>
  <files>scripts/cleanup-session.sh, hooks/hooks.json</files>
  <action>
**Part A: Create `scripts/cleanup-session.sh`**

Create a bash script (#!/usr/bin/env bash, set -euo pipefail) that handles SessionEnd events by truncating the session log.

**Implementation:**

1. Read stdin once: `INPUT=$(cat)`
2. Extract CWD in a single jq call: `CWD=$(echo "$INPUT" | jq -r '.cwd')`
3. Set up path: `LOG_FILE="${CWD}/.auto-context/session-log.jsonl"`
4. If the log file exists, truncate it: `: > "$LOG_FILE"`
   - Use `: >` (not `rm`) to truncate -- this keeps the file descriptor valid and avoids race conditions if another process has the file open
   - If the file does not exist, do nothing (session may not have had any observations)
5. `exit 0`

The script should be minimal -- no jq construction, no complex logic. Just read CWD, truncate file, exit. This ensures it stays well under 100ms.

After creating: `chmod +x scripts/cleanup-session.sh`

**Part B: Add SessionEnd entry to hooks.json**

Read the current hooks.json (which now has SessionStart, PostToolUse, PostToolUseFailure from Plan 01). Add a SessionEnd entry:

```json
"SessionEnd": [
  {
    "hooks": [
      {
        "type": "command",
        "command": "${CLAUDE_PLUGIN_ROOT}/scripts/cleanup-session.sh"
      }
    ]
  }
]
```

Note: SessionEnd has NO matcher field (it fires unconditionally on all session end reasons: clear, logout, prompt_input_exit, bypass_permissions_disabled, other).

Validate: `jq . hooks/hooks.json > /dev/null`
  </action>
  <verify>
    <automated>cd /Users/dgsw67/auto-context && bash -n scripts/cleanup-session.sh && test -x scripts/cleanup-session.sh && jq . hooks/hooks.json > /dev/null && jq -e '.hooks.SessionEnd' hooks/hooks.json > /dev/null && mkdir -p /tmp/ac-test-cleanup/.auto-context && echo '{"ts":"t","event":"test"}' > /tmp/ac-test-cleanup/.auto-context/session-log.jsonl && echo '{"session_id":"x","cwd":"/tmp/ac-test-cleanup","hook_event_name":"SessionEnd","reason":"other"}' | bash scripts/cleanup-session.sh && test "$(wc -c < /tmp/ac-test-cleanup/.auto-context/session-log.jsonl | tr -d ' ')" = "0" && rm -rf /tmp/ac-test-cleanup && echo "PASS: cleanup script works, log truncated to 0 bytes" || (rm -rf /tmp/ac-test-cleanup; echo "FAIL")</automated>
  </verify>
  <done>cleanup-session.sh exists, is executable, truncates session-log.jsonl on SessionEnd. hooks.json contains SessionEnd entry with no matcher. Log file is 0 bytes after cleanup.</done>
</task>

<task type="auto">
  <name>Task 2: Add stale session log safety net to inject-context.sh</name>
  <files>scripts/inject-context.sh</files>
  <action>
Add a stale log detection mechanism to `scripts/inject-context.sh` that fires at SessionStart, AFTER the data store initialization block and BEFORE the session_start JSONL entry is logged.

**Why:** The research documents Pitfall 1 -- SessionEnd may not fire if the process is killed (SIGKILL/SIGTERM). Without a safety net, old session log entries would accumulate and confuse Phase 5 pattern extraction.

**Implementation:**

Insert this block AFTER the session-log.jsonl creation line (`[ -f "$STORE_DIR/session-log.jsonl" ] || touch ...`) and BEFORE the `echo ... session_start ...` line:

```bash
# Safety net: clear stale session log from crashed/killed sessions
# If session-log.jsonl has entries with a different session_id, this is stale data
if [ -s "$STORE_DIR/session-log.jsonl" ]; then
  # Check if any entry has a different session_id (stale data from crashed session)
  STALE_COUNT=$(jq -r --arg sid "$SESSION_ID" 'select(.session_id != $sid) | .session_id' "$STORE_DIR/session-log.jsonl" 2>/dev/null | head -1 | wc -c | tr -d ' ')
  if [ "$STALE_COUNT" -gt 1 ]; then
    : > "$STORE_DIR/session-log.jsonl"
  fi
fi
```

**Important details:**
- Use `-s` to check file is non-empty (not just exists)
- Use `jq -r` with `select` to find entries with a different session_id
- Use `head -1 | wc -c` to check if any output exists (avoid reading entire file)
- Use `tr -d ' '` for macOS compatibility (per Phase 1 decision)
- Truncate with `: >` to keep file descriptor valid
- This runs ONCE at session start, so the jq overhead is acceptable (not in the hot PostToolUse path)
- If the log is empty or all entries match current session_id, do nothing

Do NOT change any other part of inject-context.sh. Only add this block in the specified location.
  </action>
  <verify>
    <automated>cd /Users/dgsw67/auto-context && bash -n scripts/inject-context.sh && mkdir -p /tmp/ac-test-stale/.auto-context && echo '[]' > /tmp/ac-test-stale/.auto-context/conventions.json && echo '[]' > /tmp/ac-test-stale/.auto-context/candidates.json && echo '[]' > /tmp/ac-test-stale/.auto-context/anti-patterns.json && echo '{"version":"0.1.0","token_budget":1000,"chars_per_token":3.0}' > /tmp/ac-test-stale/.auto-context/config.json && echo '{"ts":"old","event":"file_write","tool":"Write","file":"x.ts","session_id":"OLD_SESSION"}' > /tmp/ac-test-stale/.auto-context/session-log.jsonl && echo '{"session_id":"NEW_SESSION","cwd":"/tmp/ac-test-stale","hook_event_name":"SessionStart"}' | bash scripts/inject-context.sh > /dev/null 2>&1 && FIRST_LINE=$(head -1 /tmp/ac-test-stale/.auto-context/session-log.jsonl) && echo "$FIRST_LINE" | jq -e '.event == "session_start" and .session_id == "NEW_SESSION"' > /dev/null && rm -rf /tmp/ac-test-stale && echo "PASS: stale log cleared, fresh session_start entry present" || (rm -rf /tmp/ac-test-stale; echo "FAIL")</automated>
  </verify>
  <done>inject-context.sh detects stale session log entries (different session_id) at SessionStart and truncates the log before writing the new session_start entry. Fresh sessions with matching session_id are not affected. The safety net handles the case where SessionEnd did not fire.</done>
</task>

</tasks>

<verification>
1. `bash -n scripts/cleanup-session.sh` passes (no syntax errors)
2. `scripts/cleanup-session.sh` is executable
3. hooks.json has SessionEnd entry (no matcher, unconditional)
4. hooks.json remains valid JSON with all 4 hook event types
5. cleanup-session.sh truncates session-log.jsonl to 0 bytes
6. `bash -n scripts/inject-context.sh` passes after modification
7. Stale log with different session_id is cleared at SessionStart
8. Fresh log with current session_id is NOT cleared
9. New session_start entry is written after stale log cleanup
</verification>

<success_criteria>
- SessionEnd hook truncates session-log.jsonl (log never accumulates across sessions)
- SessionStart safety net detects and clears stale logs from crashed sessions
- Both scripts execute well under 100ms
- hooks.json is complete with all 4 hook types: SessionStart, PostToolUse, PostToolUseFailure, SessionEnd
- No regressions in inject-context.sh behavior (convention injection still works)
</success_criteria>

<output>
After completion, create `.planning/phases/03-session-observation/03-02-SUMMARY.md`
</output>
