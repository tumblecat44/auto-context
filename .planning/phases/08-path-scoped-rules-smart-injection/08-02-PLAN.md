---
phase: 08-path-scoped-rules-smart-injection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/path-rules.sh
  - scripts/inject-context.sh
autonomous: true
requirements:
  - PATH-01
  - PATH-02
  - PATH-03
  - INJT-02
  - INJT-03

must_haves:
  truths:
    - "Module-specific conventions are detected by checking if ALL evidence files share a common directory prefix at depth >= 2"
    - "Path-scoped conventions are written to .claude/rules/auto-context-*.md files with paths: YAML frontmatter"
    - "Conventions in CLAUDE.md are sorted by confidence descending, highest-confidence always included first"
    - "Conventions that overflow the CLAUDE.md budget are placed in .claude/rules/auto-context-overflow.md"
    - "No convention appears in both CLAUDE.md and a .claude/rules/ file"
    - "Bootstrap conventions are never path-scoped regardless of evidence"
    - "Stale auto-context-*.md rule files are cleaned up every session"
  artifacts:
    - path: "scripts/lib/path-rules.sh"
      provides: "Path-scope detection, rule file generation, cleanup"
      exports: ["detect_path_scope", "generate_rule_files", "cleanup_auto_rules"]
      min_lines: 80
    - path: "scripts/inject-context.sh"
      provides: "Smart injection pipeline with confidence sorting, path routing, overflow"
      contains: "detect_path_scope"
  key_links:
    - from: "scripts/lib/path-rules.sh"
      to: ".claude/rules/auto-context-*.md"
      via: "generate_rule_files writes path-scoped rule files"
      pattern: "auto-context-.*\\.md"
    - from: "scripts/inject-context.sh"
      to: "scripts/lib/path-rules.sh"
      via: "source and function calls"
      pattern: "source.*path-rules\\.sh"
    - from: "scripts/inject-context.sh"
      to: ".claude/rules/auto-context-overflow.md"
      via: "overflow conventions written when budget exceeded"
      pattern: "auto-context-overflow"
    - from: "scripts/inject-context.sh"
      to: "scripts/lib/tokens.sh"
      via: "Uses estimate_tokens for per-line budget accounting"
      pattern: "estimate_tokens"
---

<objective>
Create path-scoped convention detection, rule file generation, and confidence-weighted smart injection pipeline.

Purpose: This is the core intelligence of Phase 8 -- splitting the injection output into two channels (CLAUDE.md for highest-confidence global conventions, `.claude/rules/` for path-scoped and overflow conventions) and ensuring conventions are prioritized by confidence within the token budget.
Output: `scripts/lib/path-rules.sh` library and rewritten injection section in `scripts/inject-context.sh`.
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-path-scoped-rules-smart-injection/08-RESEARCH.md
@scripts/inject-context.sh
@scripts/lib/tokens.sh
@scripts/lib/lifecycle.sh
@scripts/lib/markers.sh
@.planning/phases/01-plugin-skeleton-injection/01-02-SUMMARY.md
@.planning/phases/06-convention-lifecycle-review/06-01-SUMMARY.md
@.planning/phases/07-anti-patterns-reward-signals/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create path-rules.sh library with detection and rule file generation</name>
  <files>scripts/lib/path-rules.sh</files>
  <action>
Create `scripts/lib/path-rules.sh` with these functions:

**1. `detect_path_scope(conv_json)`** -- Returns a glob pattern if convention is path-scoped, empty string if global.

Algorithm:
- Extract file paths from the convention's `evidence[].file` and `observed_in[]` arrays using jq
- Count unique files; if fewer than 3, return empty (not enough evidence for path-scoping)
- Check `source` field; if "bootstrap", return empty (bootstrap conventions are project-wide by nature)
- Find common directory prefix by iterating through file paths, using `dirname` and progressively shortening with a while loop until the prefix matches all files (or reaches ".")
- Check prefix depth (count slashes); if depth < 2 (e.g., just "src/" or "."), return empty
- Return `"${common_prefix}/**/*"` as the glob pattern

**2. `generate_rule_files(rules_dir, grouped_convs_json)`** -- Writes `.claude/rules/auto-context-*.md` files.

Takes a JSON array of `{scope: "glob_pattern", convs: ["text1", "text2"]}` groups.
For each group:
- Derive filename from the path scope: extract the deepest directory name (e.g., "src/api" -> "api", "src/components/ui" -> "ui")
- Create `.claude/rules/auto-context-{dirname}.md` with YAML frontmatter:
  ```
  ---
  paths:
    - "{glob_pattern}"
  ---

  # Auto-Context: {dirname} Conventions

  {each convention as "- text"}

  _Auto-generated by auto-context plugin. Regenerated each session._
  ```
- All glob patterns MUST be double-quoted in YAML (e.g., `"src/api/**/*"`)
- Use heredoc or printf for reliable file generation (avoid echo for multiline YAML)
- Cap at 5 path-scoped rule files; if more than 5 groups exist, merge lowest-count groups into overflow

**3. `write_overflow_file(rules_dir, overflow_texts_json)`** -- Writes `auto-context-overflow.md` for global overflow.

Takes a JSON array of convention text strings. Writes `.claude/rules/auto-context-overflow.md` WITHOUT `paths:` frontmatter (global):
```
---
---

# Auto-Context: Overflow Conventions

{each convention as "- text"}

_Auto-generated by auto-context plugin. Regenerated each session._
```

**4. `cleanup_auto_rules(rules_dir)`** -- Removes all `auto-context-*.md` files in the rules directory.

Simple: `rm -f "${rules_dir}"/auto-context-*.md 2>/dev/null || true`
ONLY removes files matching the `auto-context-` prefix. Never touches user-created rule files.

**Important conventions:**
- Include shebang `#!/usr/bin/env bash` but NO `set -euo pipefail` (this is a sourced library, like lifecycle.sh)
- All functions should be sourceable without side effects
- Use `mkdir -p` before writing to rules_dir (may not exist on first run)
- Handle empty JSON arrays gracefully (skip file generation if no conventions)
- Use consistent quoting for all file paths (handle spaces)
  </action>
  <verify>
    <automated>bash -n /Users/dgsw67/auto-context/scripts/lib/path-rules.sh && echo "SYNTAX OK" && grep -c "detect_path_scope\|generate_rule_files\|cleanup_auto_rules\|write_overflow_file" /Users/dgsw67/auto-context/scripts/lib/path-rules.sh</automated>
    <manual>Verify functions handle edge cases: empty evidence, bootstrap conventions, shallow paths</manual>
  </verify>
  <done>path-rules.sh exists with all 4 functions, passes bash -n syntax check, handles edge cases for path detection (bootstrap skip, depth check, minimum evidence threshold)</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite inject-context.sh injection section for smart confidence-sorted pipeline</name>
  <files>scripts/inject-context.sh</files>
  <action>
Modify `scripts/inject-context.sh` to add the smart injection pipeline. Source the new library at the top alongside existing sources:
```bash
source "${SCRIPT_DIR}/lib/path-rules.sh"
```

Replace the existing convention injection section (approximately lines 80-136 in current file, from `# --- Convention Injection into CLAUDE.md ---` through the `inject_content` calls) with the new smart injection pipeline:

**Step 1: Get active conventions and anti-patterns (unchanged)**
- `ACTIVE_CONVS=$(get_active_conventions "$STORE_DIR" 50)` -- already confidence-sorted
- Anti-pattern section building stays the same (200-token sub-budget with enforce_budget)

**Step 2: Separate path-scoped vs global conventions (NEW)**
- Initialize `PATH_SCOPED="[]"` and `GLOBAL_CONVS="[]"`
- Loop through each convention in ACTIVE_CONVS using jq index iteration
- For each, call `detect_path_scope "$CONV"`
- If scope returned (non-empty): add to PATH_SCOPED array with the scope
- If empty: add to GLOBAL_CONVS array

**Step 3: Clean up and generate rule files (NEW)**
- Set `RULES_DIR="${CWD}/.claude/rules"`
- Call `cleanup_auto_rules "$RULES_DIR"` to remove stale auto-context-*.md files
- If PATH_SCOPED has entries: group by scope using jq, call `generate_rule_files "$RULES_DIR" "$grouped"` with mkdir -p

**Step 4: Build CLAUDE.md content with line-by-line budget (REPLACE existing bulk truncation)**
- Instead of building all convention text then calling `enforce_budget`, iterate through GLOBAL_CONVS one by one:
  - Start with header tokens: `estimate_tokens "## Project Conventions (Auto-Context)\n\n"`
  - For each convention text (in confidence-sorted order, already sorted):
    - Build line: `"- ${conv_text}"`
    - Estimate tokens for the line (plus 1 token for newline)
    - If accumulated + line_tokens <= CONV_BUDGET: append to CONV_LINES, increment accumulated
    - If over budget: append convention text to OVERFLOW array
- This ensures highest-confidence conventions are always included and lower-confidence ones are cleanly cut

**Step 5: Write overflow file if needed (NEW)**
- If OVERFLOW array is non-empty, call `write_overflow_file "$RULES_DIR" "$OVERFLOW_JSON"`

**Step 6: Combine and inject (MODIFIED)**
- Build FULL_CONTENT from CONV_LINES (if any) + AP_CONTENT (if any) + footer
- Call ensure_markers and inject_content as before

**Critical: Preserve ALL existing non-injection logic:**
- Data store initialization (lines 1-65) -- NO CHANGES
- Lifecycle pipeline (lines 67-94) -- NO CHANGES
- Status line and hook response output (lines 138-156) -- NO CHANGES (but update CONV_COUNT to reflect only conventions injected into CLAUDE.md, not overflow ones, for accurate status)

**Anti-pattern section handling stays the same:**
- Build AP_CONTENT with 200-token sub-budget using enforce_budget (unchanged from Phase 7)
- Calculate CONV_BUDGET = TOKEN_BUDGET - AP_TOKENS - 50 (unchanged)
- The only change is HOW conventions fill that budget (line-by-line vs bulk truncation)

**Edge cases:**
- Zero active conventions: skip path detection loop entirely, inject placeholder
- Zero global conventions (all path-scoped): inject only anti-patterns section (if any) or placeholder
- Zero path-scoped conventions: no rule files generated, all go to CLAUDE.md budget
- Rules directory does not exist: mkdir -p creates it only when needed (when there ARE path-scoped or overflow conventions)
  </action>
  <verify>
    <automated>bash -n /Users/dgsw67/auto-context/scripts/inject-context.sh && echo "SYNTAX OK" && grep -c "detect_path_scope\|cleanup_auto_rules\|generate_rule_files\|write_overflow_file\|path-rules" /Users/dgsw67/auto-context/scripts/inject-context.sh</automated>
    <manual>Verify the injection pipeline: path-rules.sh sourced, path-scoped detection loop exists, line-by-line budget building replaces bulk enforce_budget for conventions, overflow handling present</manual>
  </verify>
  <done>inject-context.sh sources path-rules.sh, separates path-scoped from global conventions, generates rule files, builds CLAUDE.md content line-by-line with confidence prioritization, writes overflow to auto-context-overflow.md, and preserves all existing data store init, lifecycle pipeline, and status output logic</done>
</task>

</tasks>

<verification>
1. `bash -n scripts/lib/path-rules.sh` passes
2. `bash -n scripts/inject-context.sh` passes
3. `grep "source.*path-rules" scripts/inject-context.sh` shows the library is sourced
4. `grep "detect_path_scope" scripts/inject-context.sh` shows path detection is called
5. `grep "cleanup_auto_rules" scripts/inject-context.sh` shows stale rule cleanup
6. `grep "generate_rule_files" scripts/inject-context.sh` shows rule file generation
7. `grep "write_overflow_file" scripts/inject-context.sh` shows overflow handling
8. `grep "estimate_tokens" scripts/inject-context.sh` shows line-by-line budget accounting
9. All existing non-injection logic in inject-context.sh is preserved (data store init, lifecycle pipeline, status output)
</verification>

<success_criteria>
- Path-scoped conventions detected from evidence file paths (3+ files sharing prefix at depth >= 2, excluding bootstrap)
- Rule files generated with correct YAML frontmatter and `paths:` glob patterns
- CLAUDE.md conventions are confidence-sorted with line-by-line budget enforcement (no mid-convention truncation)
- Overflow conventions route to auto-context-overflow.md as a global rule file
- No convention appears in both CLAUDE.md and .claude/rules/
- Stale auto-context-*.md files are cleaned up before regeneration every session
- All existing inject-context.sh functionality (data store init, lifecycle, anti-patterns, status line) preserved
</success_criteria>

<output>
After completion, create `.planning/phases/08-path-scoped-rules-smart-injection/08-02-SUMMARY.md`
</output>
