---
phase: 08-path-scoped-rules-smart-injection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/file-relations.sh
  - agents/extract-patterns.md
autonomous: true
requirements:
  - BOOT-04
  - BOOT-05

must_haves:
  truths:
    - "Git co-change relationships are extracted from recent commit history into file-relations.json"
    - "Session-level file co-changes are tracked by the extraction agent at Stop hook"
    - "file-relations.json contains file pairs with counts, sources, and timestamps"
    - "Non-git projects gracefully skip git analysis without errors"
  artifacts:
    - path: "scripts/lib/file-relations.sh"
      provides: "Git co-change extraction and merge logic"
      exports: ["extract_git_cochanges"]
      min_lines: 60
    - path: "agents/extract-patterns.md"
      provides: "Session co-change tracking instructions"
      contains: "File Co-Change Tracking"
  key_links:
    - from: "scripts/lib/file-relations.sh"
      to: ".auto-context/file-relations.json"
      via: "extract_git_cochanges writes/merges file-relations.json"
      pattern: "file-relations\\.json"
    - from: "agents/extract-patterns.md"
      to: ".auto-context/file-relations.json"
      via: "Stop hook agent reads session log and updates file-relations.json"
      pattern: "file-relations\\.json"
---

<objective>
Create file co-change relationship tracking from git history and session observations.

Purpose: File co-change data enables Phase 8's path-scoped convention detection by identifying which files change together (module boundaries). This plan builds the data layer; Plan 02 uses it for path-scoped rule generation.
Output: `scripts/lib/file-relations.sh` library and extended extraction agent with session co-change tracking.
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-path-scoped-rules-smart-injection/08-RESEARCH.md
@agents/extract-patterns.md
@scripts/lib/lifecycle.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file-relations.sh library for git co-change extraction</name>
  <files>scripts/lib/file-relations.sh</files>
  <action>
Create `scripts/lib/file-relations.sh` with an `extract_git_cochanges(store_dir, max_commits)` function that:

1. Guards against non-git repos: `git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 0`
2. Uses `git log --name-only --pretty=format:"---" -${max_commits}` (default 100) to extract per-commit file lists
3. Processes commit blocks with awk to collect tab-separated file lists per commit
4. For each commit block, uses jq to generate canonical file pairs (file_a < file_b) and count co-changes
5. Aggregates duplicate pairs by summing counts using `jq group_by(.files) | map(...)`
6. Caps at 500 pairs sorted by count descending
7. Merges with existing file-relations.json: preserves session-sourced pairs, replaces git-sourced ones
8. Writes atomically via `.tmp && mv` pattern (consistent with lifecycle.sh)

**file-relations.json schema:**
```json
{
  "version": 1,
  "updated_at": "ISO-8601",
  "git_commits_analyzed": 100,
  "pairs": [
    {"files": ["path/a.ts", "path/b.ts"], "count": 12, "sources": ["git"], "last_seen": "ISO-8601"}
  ]
}
```

**Important details:**
- Use `jq -nc` for creating new JSON (not echo + jq parse) -- consistent with lifecycle.sh patterns
- Filter out empty lines and single-file commits (no pairs possible)
- For the jq combinations approach: use `[range(length)] | combinations(2) | select(.[0] < .[1])` on the files array to generate pairs, BUT if a commit has more than 20 files, skip it (merge commits or bulk refactors are noise, not meaningful co-change signals)
- All glob patterns and paths must handle spaces safely (quote all variables)
- Include shebang and set -euo pipefail
- The function should be sourceable (no top-level execution)

Also add a helper function `merge_session_cochanges(store_dir, file_pairs_json)` that:
- Takes a JSON array of `{"files": [a, b]}` pairs from session tracking
- Reads existing file-relations.json
- For each pair: if exists, increment count and add "session" to sources; if new, create with count=1, sources=["session"]
- Updates last_seen timestamp
- Writes atomically
- Caps at 500 pairs

This helper will be called by the extraction agent (via a small shell wrapper or inline in the agent's instructions).
  </action>
  <verify>
    <automated>bash -n /Users/dgsw67/auto-context/scripts/lib/file-relations.sh && echo "SYNTAX OK" && grep -c "extract_git_cochanges" /Users/dgsw67/auto-context/scripts/lib/file-relations.sh</automated>
    <manual>Verify the function handles non-git repos gracefully and produces valid JSON output</manual>
  </verify>
  <done>file-relations.sh exists with extract_git_cochanges and merge_session_cochanges functions, passes bash -n syntax check, and follows project conventions (jq -nc, atomic writes, set -euo pipefail)</done>
</task>

<task type="auto">
  <name>Task 2: Extend extraction agent with session co-change tracking</name>
  <files>agents/extract-patterns.md</files>
  <action>
Add a new section "## File Co-Change Tracking (Phase 8)" to `agents/extract-patterns.md` AFTER the "Reward Signal Computation" section and BEFORE the "Pattern Analysis" section. This positions it with the other metadata-only fast operations that run before the slower pattern extraction.

The section should instruct the agent to:

1. Collect all unique file paths from `file_write` and `file_edit` events in the session log
2. Convert to relative paths (strip cwd prefix if present)
3. Sort alphabetically, generate all unique pairs where file_a < file_b
4. Skip if fewer than 2 unique files (no pairs possible)
5. Read existing `.auto-context/file-relations.json` (create with `{"version":1,"pairs":[]}` if missing)
6. For each pair:
   - If pair already exists in file-relations.json: increment count by 1, ensure "session" is in the sources array, update last_seen to current ISO-8601 timestamp
   - If pair is new: add with count=1, sources=["session"], last_seen=current timestamp
7. Cap total pairs at 500 (keep highest count), write atomically (read -> merge -> write)
8. If any error occurs during co-change tracking, log silently and continue (consistent with existing error handling pattern)

**Important:** This is agent-driven (the extraction agent uses Read/Write tools to manipulate JSON). It does NOT call the shell library function. The shell library is for `/ac-init` bootstrap usage. The agent handles session-level tracking independently using its own JSON manipulation via tool calls.

Also update the "Final Instructions" section to mention co-change tracking in the execution order: "Perform correction detection, reward computation, and file co-change tracking FIRST (metadata-only, fast), then proceed with pattern extraction"
  </action>
  <verify>
    <automated>grep -c "File Co-Change Tracking" /Users/dgsw67/auto-context/agents/extract-patterns.md && grep -c "file-relations.json" /Users/dgsw67/auto-context/agents/extract-patterns.md</automated>
    <manual>Verify the co-change tracking section appears between Reward Signal Computation and Pattern Analysis sections</manual>
  </verify>
  <done>Extraction agent includes session co-change tracking instructions, references file-relations.json, and the execution order in Final Instructions mentions co-change tracking</done>
</task>

</tasks>

<verification>
1. `bash -n scripts/lib/file-relations.sh` passes (no syntax errors)
2. `grep "extract_git_cochanges\|merge_session_cochanges" scripts/lib/file-relations.sh` shows both functions
3. `grep "File Co-Change Tracking" agents/extract-patterns.md` shows the new section
4. `grep "file-relations.json" agents/extract-patterns.md` shows JSON file reference
5. No changes to hooks.json, inject-context.sh, or other existing scripts
</verification>

<success_criteria>
- scripts/lib/file-relations.sh exists with git co-change extraction that gracefully handles non-git projects
- Extraction agent has session co-change tracking instructions that run alongside correction detection and reward computation
- file-relations.json schema supports both git and session sources with counts and timestamps
- All output follows project conventions: atomic writes, jq-based JSON manipulation, POSIX-compatible shell
</success_criteria>

<output>
After completion, create `.planning/phases/08-path-scoped-rules-smart-injection/08-01-SUMMARY.md`
</output>
