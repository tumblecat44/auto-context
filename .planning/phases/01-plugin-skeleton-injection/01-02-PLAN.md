---
phase: 01-plugin-skeleton-injection
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - scripts/lib/markers.sh
  - scripts/lib/tokens.sh
  - scripts/inject-context.sh
autonomous: true
requirements:
  - PLUG-03
  - PLUG-04
  - INJT-01
  - INJT-04

must_haves:
  truths:
    - "Auto-context content appears inside <!-- auto-context:start/end --> markers in CLAUDE.md"
    - "User content outside markers is never modified"
    - "Marker section validates integrity on every injection (handles corruption, duplication, missing markers)"
    - "Auto-context section never exceeds 1000 tokens regardless of input"
    - "SessionStart hook reads conventions.json and injects formatted content into CLAUDE.md"
  artifacts:
    - path: "scripts/lib/markers.sh"
      provides: "Marker validation, ensure_markers, read_between_markers, inject_content functions"
      min_lines: 60
      exports: ["has_markers", "validate_markers", "ensure_markers", "inject_content"]
    - path: "scripts/lib/tokens.sh"
      provides: "Token estimation and budget enforcement functions"
      min_lines: 25
      exports: ["estimate_tokens", "enforce_budget"]
    - path: "scripts/inject-context.sh"
      provides: "Full SessionStart hook: init store, read conventions, format, enforce budget, inject into CLAUDE.md"
      min_lines: 60
  key_links:
    - from: "scripts/inject-context.sh"
      to: "scripts/lib/markers.sh"
      via: "source command"
      pattern: "source.*lib/markers\\.sh"
    - from: "scripts/inject-context.sh"
      to: "scripts/lib/tokens.sh"
      via: "source command"
      pattern: "source.*lib/tokens\\.sh"
    - from: "scripts/inject-context.sh"
      to: ".auto-context/conventions.json"
      via: "jq read to build markdown content"
      pattern: "jq.*conventions\\.json"
    - from: "scripts/lib/markers.sh"
      to: "CLAUDE.md"
      via: "awk-based marker section replacement"
      pattern: "auto-context:start"
---

<objective>
Implement CLAUDE.md marker section management with integrity validation and token budget enforcement, then wire it into the SessionStart injection pipeline.

Purpose: This is the core value delivery of Phase 1 -- conventions written to CLAUDE.md automatically, safely (user content untouched), and within a hard token budget. The marker system must handle corruption, duplication, and missing markers gracefully.

Output: A fully functional injection pipeline: SessionStart fires -> read conventions.json -> format as markdown -> enforce 1000-token budget -> validate/create markers in CLAUDE.md -> inject content between markers -> output status to Claude.
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-plugin-skeleton-injection/01-RESEARCH.md
@.planning/phases/01-plugin-skeleton-injection/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement marker management and token budget libraries</name>
  <files>
    scripts/lib/markers.sh
    scripts/lib/tokens.sh
  </files>
  <action>
Replace the stub `scripts/lib/markers.sh` with full marker section management:

**scripts/lib/markers.sh** must implement these functions:

1. **`has_markers(file)`** — Returns 0 if both start and end markers exist in file, 1 otherwise.

2. **`validate_markers(file)`** — Checks marker integrity. Returns one of:
   - "valid" (exit 0): Exactly one start marker, one end marker, start comes before end
   - "missing_both" (exit 1): No markers found
   - "missing_file" (exit 1): CLAUDE.md doesn't exist
   - "corrupted" (exit 1): Any other state (duplicates, reversed order, orphaned markers)

   Count occurrences with `grep -c`. Check ordering with `grep -n` line numbers. This handles all PLUG-04 cases: corruption, duplication, missing markers.

3. **`ensure_markers(file)`** — Guarantees valid markers exist:
   - If file doesn't exist: create it with just markers
   - If "valid": do nothing
   - If "missing_both": append markers at end of file
   - If "corrupted": remove ALL existing markers (grep -v), then append fresh pair
   - After any repair, ALWAYS verify with validate_markers() to confirm fix worked

4. **`inject_content(file, content)`** — Replace everything between markers with new content:
   - Use `awk` (NOT `sed -i` -- see research Pitfall 7 on macOS/Linux incompatibility)
   - Pattern: print lines until start marker, print start marker, print new content, skip until end marker, print end marker and continue
   - Write to temp file then `mv` (atomic replacement)
   - Temp file should be `${file}.ac-tmp` to avoid collision with other tools

Marker strings (use exact values):
```bash
MARKER_START="<!-- auto-context:start -->"
MARKER_END="<!-- auto-context:end -->"
```

**scripts/lib/tokens.sh** must implement:

1. **`estimate_tokens(text)`** — Estimate token count from text.
   - Use `chars_per_token=3.0` (conservative, safe for Korean/CJK per research)
   - Count characters: `${#text}` in bash
   - Return: `echo $(( ${#text} / 3 ))` (integer division, rounds down = conservative)

2. **`enforce_budget(content, max_tokens)`** — Truncate content to fit within token budget.
   - Calculate max_chars = max_tokens * 3
   - If content fits: return as-is
   - If content overflows: truncate to max_chars characters, append "\n\n_[truncated to fit token budget]_"
   - Use `${content:0:$max_chars}` for truncation

All functions must be POSIX-compatible (work on both macOS bash 3.2 and Linux bash 5.x). Do NOT use bash 4+ features like associative arrays or `mapfile`.
  </action>
  <verify>
    <automated>cd /Users/dgsw67/auto-context && bash -c '
source scripts/lib/markers.sh
source scripts/lib/tokens.sh

# Test markers.sh
TESTDIR=$(mktemp -d)
TESTMD="$TESTDIR/CLAUDE.md"

# Test 1: missing_file
RESULT=$(validate_markers "$TESTMD" 2>/dev/null) || true
[ "$RESULT" = "missing_file" ] && echo "PASS: missing_file" || echo "FAIL: missing_file got $RESULT"

# Test 2: ensure_markers creates file
ensure_markers "$TESTMD"
RESULT=$(validate_markers "$TESTMD")
[ "$RESULT" = "valid" ] && echo "PASS: ensure creates markers" || echo "FAIL: ensure got $RESULT"

# Test 3: inject_content preserves user content
echo -e "# My Project\nSome user content\n<!-- auto-context:start -->\n<!-- auto-context:end -->\nMore user stuff" > "$TESTMD"
inject_content "$TESTMD" "## Auto conventions here"
grep -q "My Project" "$TESTMD" && echo "PASS: user content preserved" || echo "FAIL: user content lost"
grep -q "Auto conventions here" "$TESTMD" && echo "PASS: content injected" || echo "FAIL: content not injected"
grep -q "More user stuff" "$TESTMD" && echo "PASS: trailing content preserved" || echo "FAIL: trailing content lost"

# Test 4: corrupted markers (duplicate start)
echo -e "<!-- auto-context:start -->\n<!-- auto-context:start -->\n<!-- auto-context:end -->" > "$TESTMD"
ensure_markers "$TESTMD"
RESULT=$(validate_markers "$TESTMD")
[ "$RESULT" = "valid" ] && echo "PASS: corruption repaired" || echo "FAIL: corruption not repaired: $RESULT"

# Test 5: token budget
RESULT=$(estimate_tokens "hello world 123")
[ "$RESULT" -ge 4 ] && echo "PASS: token estimate" || echo "FAIL: token estimate $RESULT"

# Test 6: enforce_budget truncation
LONG=$(printf "x%.0s" {1..4000})
RESULT=$(enforce_budget "$LONG" 1000)
[ ${#RESULT} -le 3100 ] && echo "PASS: budget enforced" || echo "FAIL: budget not enforced ${#RESULT}"

rm -rf "$TESTDIR"
echo "All marker and token tests completed"
'</automated>
    <manual>Verify marker functions handle: missing file, missing markers, valid markers, corrupted markers, content injection with user content preservation, token budget truncation</manual>
  </verify>
  <done>markers.sh provides has_markers, validate_markers, ensure_markers, inject_content functions that handle all PLUG-04 integrity cases. tokens.sh provides estimate_tokens and enforce_budget functions with conservative 3.0 chars/token ratio. All functions work on both macOS and Linux (no sed -i, no bash 4+ features).</done>
</task>

<task type="auto">
  <name>Task 2: Wire injection pipeline into inject-context.sh</name>
  <files>
    scripts/inject-context.sh
  </files>
  <action>
Update `scripts/inject-context.sh` (created in Plan 01-01) to add the full convention injection pipeline between the data store initialization and the status output.

Add the following section after the "Data Store Initialization" block and before the "Count conventions for status" block:

```bash
# --- Convention Injection into CLAUDE.md ---
CLAUDE_MD="${CWD}/CLAUDE.md"
CONVENTIONS_FILE="$STORE_DIR/conventions.json"
TOKEN_BUDGET=$(jq -r '.token_budget // 1000' "$STORE_DIR/config.json" 2>/dev/null || echo 1000)

# Read conventions and format as markdown
CONV_COUNT=$(jq 'length' "$CONVENTIONS_FILE" 2>/dev/null || echo 0)

if [ "$CONV_COUNT" -gt 0 ]; then
  # Build markdown content from conventions array
  # Each convention object has: { "text": "...", "confidence": N }
  CONTENT=$(jq -r '
    "## Project Conventions (Auto-Context)\n\n" +
    (map("- " + .text) | join("\n")) +
    "\n\n_Auto-generated by auto-context plugin. Do not edit between markers._"
  ' "$CONVENTIONS_FILE" 2>/dev/null || echo "")

  if [ -n "$CONTENT" ]; then
    # Enforce token budget
    CONTENT=$(enforce_budget "$CONTENT" "$TOKEN_BUDGET")

    # Ensure CLAUDE.md has valid markers (creates file if needed, repairs if corrupted)
    ensure_markers "$CLAUDE_MD"

    # Inject content between markers
    inject_content "$CLAUDE_MD" "$CONTENT"
  fi
else
  # No conventions yet -- ensure markers exist but inject empty placeholder
  # Only touch CLAUDE.md if it already exists (don't create empty file per research recommendation)
  if [ -f "$CLAUDE_MD" ]; then
    ensure_markers "$CLAUDE_MD"
    inject_content "$CLAUDE_MD" "_No conventions yet. Auto-Context is learning from your sessions._"
  fi
fi
```

Important implementation details:
- Only create CLAUDE.md if there are actual conventions to inject (per research Open Question 4)
- If CLAUDE.md already exists but has no conventions, add placeholder text between markers
- Token budget comes from config.json (default 1000 if missing)
- Convention JSON format assumed: `[{"text": "Use async/await", "confidence": 0.8}, ...]`
- The `enforce_budget` call MUST happen BEFORE `inject_content` (budget check on formatted content, not raw JSON)
- Use `ensure_markers` before EVERY injection (handles all PLUG-04 integrity cases)

Also update the status output section to use the actual convention/candidate counts that were already computed.
  </action>
  <verify>
    <automated>cd /Users/dgsw67/auto-context && bash -c '
TESTDIR=$(mktemp -d)

# Setup: create .auto-context with conventions
mkdir -p "$TESTDIR/.auto-context"
echo "[{\"text\":\"Use async/await over .then() chains\",\"confidence\":0.8},{\"text\":\"Name test files with .test.ts suffix\",\"confidence\":0.7}]" > "$TESTDIR/.auto-context/conventions.json"
echo "[]" > "$TESTDIR/.auto-context/candidates.json"
echo "[]" > "$TESTDIR/.auto-context/anti-patterns.json"
echo "{\"version\":\"0.1.0\",\"token_budget\":1000,\"chars_per_token\":3.0}" > "$TESTDIR/.auto-context/config.json"
touch "$TESTDIR/.auto-context/session-log.jsonl"

# Setup: create CLAUDE.md with existing user content
cat > "$TESTDIR/CLAUDE.md" << USERMD
# My Project

This is my project documentation.

## Build Commands
- npm run build
- npm test
USERMD

# Run injection
OUTPUT=$(echo "{\"cwd\":\"$TESTDIR\",\"session_id\":\"test-456\"}" | bash scripts/inject-context.sh)

# Verify: user content preserved
grep -q "My Project" "$TESTDIR/CLAUDE.md" && echo "PASS: user content preserved" || echo "FAIL: user content lost"
grep -q "npm run build" "$TESTDIR/CLAUDE.md" && echo "PASS: build commands preserved" || echo "FAIL: build commands lost"

# Verify: markers present
grep -q "auto-context:start" "$TESTDIR/CLAUDE.md" && echo "PASS: start marker present" || echo "FAIL: start marker missing"
grep -q "auto-context:end" "$TESTDIR/CLAUDE.md" && echo "PASS: end marker present" || echo "FAIL: end marker missing"

# Verify: conventions injected
grep -q "async/await" "$TESTDIR/CLAUDE.md" && echo "PASS: convention injected" || echo "FAIL: convention not injected"
grep -q "test.ts" "$TESTDIR/CLAUDE.md" && echo "PASS: second convention injected" || echo "FAIL: second convention not injected"

# Verify: output is valid JSON with status
echo "$OUTPUT" | jq -e ".hookSpecificOutput.additionalContext" > /dev/null && echo "PASS: valid hook output" || echo "FAIL: invalid hook output"

# Verify: idempotent (run again, no corruption)
echo "{\"cwd\":\"$TESTDIR\",\"session_id\":\"test-789\"}" | bash scripts/inject-context.sh > /dev/null
START_COUNT=$(grep -c "auto-context:start" "$TESTDIR/CLAUDE.md")
END_COUNT=$(grep -c "auto-context:end" "$TESTDIR/CLAUDE.md")
[ "$START_COUNT" -eq 1 ] && [ "$END_COUNT" -eq 1 ] && echo "PASS: idempotent (no duplicate markers)" || echo "FAIL: marker duplication after re-run"

# Verify: token budget enforcement
LARGE_CONVS=$(python3 -c "import json; print(json.dumps([{\"text\":\"x\"*100,\"confidence\":0.5} for _ in range(50)]))")
echo "$LARGE_CONVS" > "$TESTDIR/.auto-context/conventions.json"
echo "{\"cwd\":\"$TESTDIR\",\"session_id\":\"test-budget\"}" | bash scripts/inject-context.sh > /dev/null
SECTION=$(awk "/auto-context:start/,/auto-context:end/" "$TESTDIR/CLAUDE.md")
SECTION_LEN=${#SECTION}
# 1000 tokens * 3 chars = 3000 chars max + some overhead for markers
[ "$SECTION_LEN" -lt 3500 ] && echo "PASS: token budget enforced ($SECTION_LEN chars)" || echo "FAIL: token budget exceeded ($SECTION_LEN chars)"

rm -rf "$TESTDIR"
echo "All injection pipeline tests completed"
'</automated>
    <manual>Create a test CLAUDE.md with user content, run inject-context.sh with mock conventions, verify: (1) user content untouched, (2) conventions appear between markers, (3) running twice doesn't duplicate markers, (4) large input is truncated within token budget</manual>
  </verify>
  <done>SessionStart hook reads conventions.json, formats as markdown bullet list, enforces 1000-token budget, injects between <!-- auto-context:start/end --> markers in CLAUDE.md. User content outside markers is untouched. Marker integrity is validated and repaired before every injection. Running the hook multiple times is idempotent (no marker duplication). Hook output includes convention/candidate counts in additionalContext.</done>
</task>

</tasks>

<verification>
1. **Marker integrity (PLUG-04):** Test all cases:
   - Missing CLAUDE.md → markers created with content
   - Missing both markers → markers appended
   - Corrupted markers (duplicates, reversed) → repaired then injected
   - Valid markers → content replaced cleanly
2. **User content safety (PLUG-03):** Write user content before and after markers, verify untouched after injection
3. **Token budget (INJT-01):** Create 50+ conventions exceeding 1000 tokens, verify section is truncated with indicator
4. **Injection pipeline (INJT-04):** End-to-end: mock stdin → init store → read conventions → inject → verify CLAUDE.md
5. **Idempotency:** Run inject-context.sh twice, verify no duplicate markers or content
6. **Empty state:** No conventions → placeholder text if CLAUDE.md exists, no file creation if it doesn't
</verification>

<success_criteria>
- CLAUDE.md auto-content appears ONLY inside <!-- auto-context:start --> and <!-- auto-context:end --> markers
- Content outside markers is byte-for-byte identical before and after injection
- Marker validation handles: missing file, missing markers, duplicate markers, reversed markers, orphaned markers
- Auto-context section never exceeds 1000 tokens (verified by char count / 3.0)
- inject-context.sh runs end-to-end from SessionStart hook input to CLAUDE.md modification + status output
- Multiple runs of inject-context.sh produce identical CLAUDE.md (idempotent)
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-skeleton-injection/01-02-SUMMARY.md`
</output>
