---
phase: 01-plugin-skeleton-injection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .claude-plugin/plugin.json
  - hooks/hooks.json
  - scripts/inject-context.sh
  - scripts/lib/markers.sh
  - scripts/lib/tokens.sh
  - .gitignore
autonomous: true
requirements:
  - PLUG-01
  - PLUG-02
  - PLUG-05
  - OBSV-04

must_haves:
  truths:
    - "Plugin manifest is valid and passes `claude plugin validate .`"
    - "Plugin installs with zero user configuration"
    - "Data store (.auto-context/) initializes with correct JSON files on first run"
    - "Session log uses JSONL format (one JSON object per line, O(1) append)"
  artifacts:
    - path: ".claude-plugin/plugin.json"
      provides: "Plugin manifest with name, version, hooks reference"
      contains: "auto-context"
    - path: "hooks/hooks.json"
      provides: "SessionStart hook configuration pointing to inject-context.sh"
      contains: "SessionStart"
    - path: "scripts/inject-context.sh"
      provides: "Main hook script: reads stdin, inits store, sources libs, outputs status JSON"
      min_lines: 40
    - path: "scripts/lib/markers.sh"
      provides: "Stub library for marker functions (populated in Plan 02)"
      min_lines: 5
    - path: "scripts/lib/tokens.sh"
      provides: "Stub library for token budget functions (populated in Plan 02)"
      min_lines: 5
  key_links:
    - from: "hooks/hooks.json"
      to: "scripts/inject-context.sh"
      via: "command hook reference using ${CLAUDE_PLUGIN_ROOT}"
      pattern: "CLAUDE_PLUGIN_ROOT.*inject-context"
    - from: "scripts/inject-context.sh"
      to: ".auto-context/"
      via: "mkdir -p and conditional JSON file creation"
      pattern: "auto-context"
---

<objective>
Create the Claude Code plugin scaffold with a valid manifest, hook configuration, main entry script, and data store initialization.

Purpose: Establish the foundational plugin package that Claude Code can validate and install. The data store (.auto-context/) is initialized on first SessionStart, and the JSONL session log format is established for future observation hooks.

Output: A valid plugin package that passes `claude plugin validate .`, registers a SessionStart hook, initializes the .auto-context/ data store on first run, and outputs a status message to Claude's context.
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-plugin-skeleton-injection/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plugin manifest and hook configuration</name>
  <files>
    .claude-plugin/plugin.json
    hooks/hooks.json
    scripts/lib/markers.sh
    scripts/lib/tokens.sh
    .gitignore
  </files>
  <action>
Create the plugin directory structure and configuration files:

1. **`.claude-plugin/plugin.json`** — Plugin manifest:
```json
{
  "name": "auto-context",
  "version": "0.1.0",
  "description": "Automatic context engineering - project conventions accumulate and refine as you code",
  "author": {
    "name": "dgsw67",
    "url": "https://github.com/dgsw67"
  },
  "repository": "https://github.com/dgsw67/auto-context",
  "license": "MIT",
  "keywords": ["context-engineering", "CLAUDE.md", "automation", "conventions"],
  "hooks": "./hooks/hooks.json"
}
```

2. **`hooks/hooks.json`** — SessionStart hook pointing to inject script:
```json
{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "${CLAUDE_PLUGIN_ROOT}/scripts/inject-context.sh"
          }
        ]
      }
    ]
  }
}
```

3. **`scripts/lib/markers.sh`** — Stub library (Plan 02 will populate):
```bash
#!/usr/bin/env bash
# Marker section management for CLAUDE.md
# Populated by Plan 01-02
```

4. **`scripts/lib/tokens.sh`** — Stub library (Plan 02 will populate):
```bash
#!/usr/bin/env bash
# Token budget enforcement
# Populated by Plan 01-02
```

5. **`.gitignore`** — Update to include `.auto-context/` directory (this is user-project runtime data, not plugin source):
Add `.auto-context/` to the existing .gitignore. This directory is created in user projects at runtime, not in the plugin source. Also ensure `*.tmp` is ignored for safe file operations.

6. Create empty `skills/` and `agents/` directories with `.gitkeep` files so the plugin structure is complete for future phases.

All shell scripts must be created with executable permissions (`chmod +x`).
  </action>
  <verify>
    <automated>cd /Users/dgsw67/auto-context && test -f .claude-plugin/plugin.json && test -f hooks/hooks.json && test -f scripts/lib/markers.sh && test -f scripts/lib/tokens.sh && jq empty .claude-plugin/plugin.json && jq empty hooks/hooks.json && echo "PASS: All config files valid"</automated>
    <manual>Verify plugin.json has name "auto-context" and hooks points to ./hooks/hooks.json</manual>
  </verify>
  <done>plugin.json is valid JSON with name "auto-context", hooks.json configures SessionStart command hook pointing to inject-context.sh via ${CLAUDE_PLUGIN_ROOT}, stub lib files exist, directory structure is complete</done>
</task>

<task type="auto">
  <name>Task 2: Create inject-context.sh with data store initialization and JSONL format</name>
  <files>
    scripts/inject-context.sh
  </files>
  <action>
Create the main SessionStart hook script `scripts/inject-context.sh`:

```bash
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Read hook input from stdin (can only be read once)
INPUT=$(cat)
CWD=$(echo "$INPUT" | jq -r '.cwd')
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // "unknown"')

# Source library functions
source "${SCRIPT_DIR}/lib/markers.sh"
source "${SCRIPT_DIR}/lib/tokens.sh"

# --- Data Store Initialization ---
STORE_DIR="${CWD}/.auto-context"
mkdir -p "$STORE_DIR"

# Initialize JSON data files only if they don't exist (preserve existing data)
[ -f "$STORE_DIR/conventions.json" ]   || echo '[]' > "$STORE_DIR/conventions.json"
[ -f "$STORE_DIR/candidates.json" ]    || echo '[]' > "$STORE_DIR/candidates.json"
[ -f "$STORE_DIR/anti-patterns.json" ] || echo '[]' > "$STORE_DIR/anti-patterns.json"
[ -f "$STORE_DIR/config.json" ]        || cat > "$STORE_DIR/config.json" << 'CONF'
{
  "version": "0.1.0",
  "token_budget": 1000,
  "chars_per_token": 3.0
}
CONF

# Session log: JSONL format — one JSON object per line, O(1) append
# Create if missing but never overwrite (may have current session data)
[ -f "$STORE_DIR/session-log.jsonl" ] || touch "$STORE_DIR/session-log.jsonl"

# Log session start event in JSONL format
echo "{\"ts\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"event\":\"session_start\",\"session_id\":\"${SESSION_ID}\",\"cwd\":\"${CWD}\"}" >> "$STORE_DIR/session-log.jsonl"

# --- Convention Injection (stub for Plan 02) ---
# Plan 01-02 will add: read conventions, format markdown, enforce token budget, inject into CLAUDE.md markers

# --- Count conventions for status ---
CONV_COUNT=$(jq 'length' "$STORE_DIR/conventions.json" 2>/dev/null || echo 0)
CAND_COUNT=$(jq 'length' "$STORE_DIR/candidates.json" 2>/dev/null || echo 0)

# Output hook response with additionalContext for Claude
cat << EOF
{
  "hookSpecificOutput": {
    "hookEventName": "SessionStart",
    "additionalContext": "Auto-Context: ${CONV_COUNT} conventions active, ${CAND_COUNT} candidates pending"
  }
}
EOF

exit 0
```

Key implementation details:
- Use `set -euo pipefail` for strict error handling
- Read stdin ONCE into `$INPUT` variable (stdin is a stream, cannot be re-read)
- Use `jq -r` for field extraction from hook input JSON
- Use conservative `chars_per_token: 3.0` (not 3.5) for safety margin with non-English content per research recommendation
- JSONL session log: each `echo '...' >>` is an atomic O(1) append, no array rewriting
- Data files initialized with empty arrays `[]` only if they don't exist (idempotent)
- Script must be `chmod +x`
  </action>
  <verify>
    <automated>cd /Users/dgsw67/auto-context && test -x scripts/inject-context.sh && echo '{"cwd":"/tmp/test-ac","session_id":"test-123"}' | bash scripts/inject-context.sh && test -d /tmp/test-ac/.auto-context && test -f /tmp/test-ac/.auto-context/conventions.json && test -f /tmp/test-ac/.auto-context/session-log.jsonl && jq empty /tmp/test-ac/.auto-context/conventions.json && tail -1 /tmp/test-ac/.auto-context/session-log.jsonl | jq -e '.event == "session_start"' && rm -rf /tmp/test-ac && echo "PASS: inject-context.sh works correctly"</automated>
    <manual>Run inject-context.sh with mock input, verify .auto-context/ created with all expected files, session-log.jsonl has valid JSONL entry, output is valid JSON with additionalContext</manual>
  </verify>
  <done>inject-context.sh reads hook stdin, initializes .auto-context/ directory with conventions.json, candidates.json, anti-patterns.json, config.json (all valid JSON), session-log.jsonl (JSONL format with session_start event), and outputs valid hook response JSON with convention/candidate counts</done>
</task>

</tasks>

<verification>
1. `jq empty .claude-plugin/plugin.json` — manifest is valid JSON
2. `jq empty hooks/hooks.json` — hooks config is valid JSON
3. `echo '{"cwd":"/tmp/test-verify","session_id":"s1"}' | bash scripts/inject-context.sh` — script runs without error, outputs valid JSON
4. Verify /tmp/test-verify/.auto-context/ contains: conventions.json, candidates.json, anti-patterns.json, config.json, session-log.jsonl
5. `tail -1 /tmp/test-verify/.auto-context/session-log.jsonl | jq .` — JSONL entry is valid JSON with event field
6. Run script twice with same cwd — verify existing data files are NOT overwritten (idempotent)
7. `rm -rf /tmp/test-verify` — cleanup
</verification>

<success_criteria>
- plugin.json is valid and contains name "auto-context", version "0.1.0", hooks reference
- hooks.json configures SessionStart command hook using ${CLAUDE_PLUGIN_ROOT}/scripts/inject-context.sh
- inject-context.sh is executable, reads stdin JSON, initializes .auto-context/ data store
- All .auto-context/ JSON files are valid JSON (arrays or objects as appropriate)
- Session log entries are JSONL format (one valid JSON per line, appended via >>)
- Script is idempotent (running twice doesn't corrupt existing data)
- Hook output is valid JSON with hookSpecificOutput.additionalContext status message
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-skeleton-injection/01-01-SUMMARY.md`
</output>
