---
phase: 06-convention-lifecycle-review
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/lifecycle.sh
  - scripts/inject-context.sh
  - scripts/detect-feedback.sh
autonomous: true
requirements:
  - LIFE-01
  - LIFE-02
  - LIFE-03
  - LIFE-04
  - LIFE-05
  - TRNS-05

must_haves:
  truths:
    - "SessionStart increments a monotonic session counter in lifecycle.json (only on startup matcher, not resume/compact)"
    - "Candidates with 3+ observations across 2+ sessions are promoted to stage review_pending"
    - "Active conventions not referenced in 5+ sessions are marked stage decayed"
    - "Decayed conventions are excluded from CLAUDE.md injection"
    - "Only the top 50 active conventions (by confidence) are injected into CLAUDE.md"
    - "Existing conventions from Phase 2 (bootstrap) and Phase 4 (explicit) are migrated with stage:active and last_referenced_session:0"
    - "All lifecycle transitions are logged to changelog.jsonl with timestamps and reasons"
    - "Explicit feedback from detect-feedback.sh includes stage:active and last_referenced_session fields"
  artifacts:
    - path: "scripts/lib/lifecycle.sh"
      provides: "Lifecycle helper functions for promotion, decay, migration, cap enforcement, and changelog logging"
      contains: "promote_candidates"
    - path: "scripts/inject-context.sh"
      provides: "SessionStart pipeline with lifecycle logic"
      contains: "lifecycle.json"
    - path: "scripts/detect-feedback.sh"
      provides: "Explicit feedback with lifecycle stage fields"
      contains: "stage"
  key_links:
    - from: "scripts/inject-context.sh"
      to: "scripts/lib/lifecycle.sh"
      via: "source statement"
      pattern: "source.*lifecycle\\.sh"
    - from: "scripts/inject-context.sh"
      to: ".auto-context/lifecycle.json"
      via: "session counter read/write"
      pattern: "lifecycle\\.json"
    - from: "scripts/inject-context.sh"
      to: ".auto-context/changelog.jsonl"
      via: "lifecycle transition logging"
      pattern: "changelog\\.jsonl"
    - from: "scripts/inject-context.sh"
      to: ".auto-context/conventions.json"
      via: "decay check and cap enforcement filter on stage==active"
      pattern: "stage.*active"
---

<objective>
Implement the convention lifecycle state machine: session counter tracking, candidate promotion to review_pending, convention decay after inactivity, 50-convention cap enforcement, backward-compatible migration of existing entries, and changelog audit trail. This is the governance core of Phase 6.

Purpose: Without lifecycle logic, all conventions are treated equally regardless of validation status. This plan introduces the 4-stage lifecycle (observation -> review_pending -> active -> decayed) and ensures only reviewed, active conventions reach CLAUDE.md.
Output: Updated inject-context.sh with lifecycle pipeline, new lifecycle.sh library, updated detect-feedback.sh with stage fields, lifecycle.json and changelog.jsonl data files.
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-convention-lifecycle-review/06-RESEARCH.md
@scripts/inject-context.sh
@scripts/detect-feedback.sh
@scripts/lib/markers.sh
@scripts/lib/tokens.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lifecycle helper library and update detect-feedback.sh</name>
  <files>scripts/lib/lifecycle.sh, scripts/detect-feedback.sh</files>
  <action>
**1. Create `scripts/lib/lifecycle.sh`** with the following shell functions:

**init_lifecycle(store_dir):**
- Initialize `lifecycle.json` if missing: `{"session_count":0,"last_session_id":"","last_promotion_check":0,"last_decay_check":0,"created_at":"$TS","updated_at":"$TS"}`
- Initialize `changelog.jsonl` if missing: `touch`
- No-op if files already exist

**increment_session(store_dir, session_id):**
- Read current `session_count` and `last_session_id` from lifecycle.json
- If `session_id` matches `last_session_id`, return early (resume/compact -- same session)
- Increment `session_count`, update `last_session_id` and `updated_at`
- Write atomically (jq + tmp + mv pattern)
- Echo the new session_count to stdout for caller use

**migrate_conventions(store_dir, session_count):**
- Read conventions.json
- For entries missing `stage` field: add `"stage": "active"` (backward compat for Phase 2/4 entries)
- For entries missing `last_referenced_session` field: add `"last_referenced_session": $session_count` (treat current session as first reference to prevent immediate decay)
- Write atomically only if changes were made
- Use jq `//` alternative operator: `if .stage then . else . + {"stage":"active"} end`

**promote_candidates(store_dir):**
- Read candidates.json
- Filter for entries where: `stage == "observation"` AND `observations >= 3` AND `(sessions_seen | length) >= 2`
- For qualifying entries: set `stage = "review_pending"`, set `promoted_at = $TS`
- Write updated candidates.json atomically
- For each promoted candidate: append a line to changelog.jsonl with `{"ts":"...","action":"promoted","text":"...","reason":"3+ observations across 2+ sessions","from_stage":"observation","to_stage":"review_pending"}`
- Use jq for filtering and updating; use `jq -nc` for changelog entries (same pattern as Phase 4 session log)

**decay_conventions(store_dir, session_count):**
- Read conventions.json
- Filter for entries where: `stage == "active"` AND `last_referenced_session > 0` AND `(session_count - last_referenced_session) >= 5`
- For qualifying entries: set `stage = "decayed"`, set `decayed_at = $TS`
- Write atomically
- Log each decay to changelog.jsonl with reason including session counts
- Use defensive `(.last_referenced_session // 0)` to handle missing field

**get_active_conventions(store_dir, max_count):**
- Read conventions.json
- Filter for `stage == "active"` only (exclude decayed, review_pending, etc.)
- Sort by `-.confidence` (highest first)
- Take first `$max_count` entries (default 50)
- If any active conventions beyond max_count exist, log each eviction to changelog.jsonl
- Output the filtered JSON array to stdout
- Return count via exit code is impractical, so the caller reads stdout

**log_changelog(store_dir, action, text, reason, from_stage, to_stage):**
- Helper to append a single JSONL entry to changelog.jsonl
- Use `jq -nc` with named args (same pattern as Phase 4)
- Format: `{"ts":"...","action":"$action","text":"$text","reason":"$reason","from_stage":"$from_stage","to_stage":"$to_stage"}`

All functions follow project patterns:
- Atomic writes: jq > .tmp && mv .tmp original
- POSIX date: `date -u +%Y-%m-%dT%H:%M:%SZ`
- Defensive field access: jq `//` operator for missing fields
- No side effects on error: `|| true` where appropriate

**2. Update `scripts/detect-feedback.sh`:**
- In the jq command that appends to conventions.json (line ~78-80), add two new fields to the JSON object:
  - `"stage": "active"` -- explicit feedback is user-approved by definition (LIFE-06 research note)
  - `"last_referenced_session": 0` -- will be updated on next SessionStart injection
- The existing fields (text, confidence, source, created_at, session_id) remain unchanged
- This ensures new explicit feedback entries have the lifecycle fields from the start, avoiding migration on every SessionStart
  </action>
  <verify>
    <automated>bash -n scripts/lib/lifecycle.sh && bash -n scripts/detect-feedback.sh && grep -q "promote_candidates" scripts/lib/lifecycle.sh && grep -q "decay_conventions" scripts/lib/lifecycle.sh && grep -q "get_active_conventions" scripts/lib/lifecycle.sh && grep -q "stage" scripts/detect-feedback.sh && echo "PASS"</automated>
    <manual>Verify lifecycle.sh has all 7 functions (init_lifecycle, increment_session, migrate_conventions, promote_candidates, decay_conventions, get_active_conventions, log_changelog). Verify detect-feedback.sh jq call includes stage:active and last_referenced_session:0 fields.</manual>
  </verify>
  <done>lifecycle.sh exists with all lifecycle helper functions. detect-feedback.sh includes stage and last_referenced_session fields in explicit feedback entries. Both files pass bash -n syntax check.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate lifecycle pipeline into inject-context.sh</name>
  <files>scripts/inject-context.sh</files>
  <action>
Modify `scripts/inject-context.sh` to add the lifecycle pipeline between data store initialization and convention injection. The existing injection logic (marker management, token budget) remains but now operates on lifecycle-filtered conventions.

**Changes to inject-context.sh in order:**

**A. Source lifecycle library (after existing source statements, ~line 12):**
```bash
source "${SCRIPT_DIR}/lib/lifecycle.sh"
```

**B. Initialize lifecycle data (after data store init block, ~line 33):**
```bash
# --- Lifecycle Initialization ---
init_lifecycle "$STORE_DIR"
```

**C. Increment session counter and run lifecycle checks (after session start log entry, ~line 45):**
```bash
# --- Lifecycle Pipeline ---
# Increment session counter (only for new sessions, not resume/compact)
SESSION_COUNT=$(increment_session "$STORE_DIR" "$SESSION_ID")

# Migrate existing conventions/candidates that lack lifecycle fields
migrate_conventions "$STORE_DIR" "$SESSION_COUNT"

# Promote eligible candidates to review_pending
promote_candidates "$STORE_DIR"

# Decay stale conventions (not referenced in 5+ sessions)
decay_conventions "$STORE_DIR" "$SESSION_COUNT"
```

**D. Replace the convention injection section (starting ~line 47):**

Replace the current CONV_COUNT / CONTENT / injection block with lifecycle-aware logic:

```bash
# --- Convention Injection into CLAUDE.md ---
CLAUDE_MD="${CWD}/CLAUDE.md"
TOKEN_BUDGET=$(jq -r '.token_budget // 1000' "$STORE_DIR/config.json" 2>/dev/null || echo 1000)

# Get active conventions filtered by stage and capped at 50
ACTIVE_CONVS=$(get_active_conventions "$STORE_DIR" 50)
CONV_COUNT=$(echo "$ACTIVE_CONVS" | jq 'length')

# Update last_referenced_session for all injected conventions
if [ "$CONV_COUNT" -gt 0 ]; then
  # Mark each active convention as referenced in this session
  jq --argjson sc "$SESSION_COUNT" '
    [.[] | if .stage == "active" then .last_referenced_session = $sc else . end]
  ' "$STORE_DIR/conventions.json" > "$STORE_DIR/conventions.json.tmp" \
    && mv "$STORE_DIR/conventions.json.tmp" "$STORE_DIR/conventions.json"
fi

CAND_COUNT=$(jq 'length' "$STORE_DIR/candidates.json" 2>/dev/null || echo 0)
AP_COUNT=$(jq 'length' "$STORE_DIR/anti-patterns.json" 2>/dev/null || echo 0)

if [ "$CONV_COUNT" -gt 0 ]; then
  # Build markdown from active conventions only (not all conventions)
  CONTENT=$(echo "$ACTIVE_CONVS" | jq -r '
    "## Project Conventions (Auto-Context)\n\n" +
    (map("- " + .text) | join("\n")) +
    "\n\n_Auto-generated by auto-context plugin. Do not edit between markers._"
  ' 2>/dev/null || echo "")

  if [ -n "$CONTENT" ]; then
    CONTENT=$(enforce_budget "$CONTENT" "$TOKEN_BUDGET")
    ensure_markers "$CLAUDE_MD"
    inject_content "$CLAUDE_MD" "$CONTENT"
  fi
else
  if [ -f "$CLAUDE_MD" ]; then
    ensure_markers "$CLAUDE_MD"
    inject_content "$CLAUDE_MD" "_No conventions yet. Auto-Context is learning from your sessions._"
  fi
fi
```

**E. Update status line to include review_pending count:**
```bash
# Count review-pending candidates for user awareness
REVIEW_COUNT=$(jq '[.[] | select(.stage == "review_pending")] | length' "$STORE_DIR/candidates.json" 2>/dev/null || echo 0)

STATUS_LINE="Auto-Context: ${CONV_COUNT} conventions active, ${CAND_COUNT} candidates pending"
[ "$REVIEW_COUNT" -gt 0 ] 2>/dev/null && STATUS_LINE="${STATUS_LINE} (${REVIEW_COUNT} ready for review)"
[ "$AP_COUNT" -gt 0 ] 2>/dev/null && STATUS_LINE="${STATUS_LINE}, ${AP_COUNT} anti-patterns"
```

**Critical constraints:**
- Preserve all existing functionality (markers, token budget, status line, session log)
- Use atomic jq + tmp + mv for all JSON writes
- SESSION_COUNT variable must be available for the last_referenced_session update
- The `get_active_conventions` function returns a JSON array via stdout -- capture in variable, not pipe
- Defensive: if lifecycle.json is missing or corrupt, init_lifecycle handles it gracefully
- Preserve the existing hook JSON output format (hookSpecificOutput with additionalContext)
  </action>
  <verify>
    <automated>bash -n scripts/inject-context.sh && grep -q "lifecycle.sh" scripts/inject-context.sh && grep -q "increment_session" scripts/inject-context.sh && grep -q "promote_candidates" scripts/inject-context.sh && grep -q "decay_conventions" scripts/inject-context.sh && grep -q "get_active_conventions" scripts/inject-context.sh && grep -q "last_referenced_session" scripts/inject-context.sh && echo "PASS"</automated>
    <manual>Verify inject-context.sh pipeline order: init lifecycle -> increment session -> migrate -> promote -> decay -> get active (capped at 50) -> update last_referenced_session -> build markdown -> enforce budget -> inject. Status line includes review count when > 0. All existing hook output preserved.</manual>
  </verify>
  <done>inject-context.sh includes full lifecycle pipeline: session counter increment, backward-compatible migration, candidate promotion, convention decay, 50-convention cap, last_referenced_session tracking, and review-pending count in status line. Script passes bash -n syntax check. All existing injection functionality preserved.</done>
</task>

</tasks>

<verification>
- `bash -n scripts/lib/lifecycle.sh` passes (valid bash)
- `bash -n scripts/inject-context.sh` passes (valid bash)
- `bash -n scripts/detect-feedback.sh` passes (valid bash)
- lifecycle.sh contains all 7 functions: init_lifecycle, increment_session, migrate_conventions, promote_candidates, decay_conventions, get_active_conventions, log_changelog
- inject-context.sh sources lifecycle.sh and calls lifecycle functions in correct order
- inject-context.sh filters conventions by stage==active and caps at 50
- inject-context.sh updates last_referenced_session for injected conventions
- detect-feedback.sh includes stage and last_referenced_session in new entries
- All JSON writes use atomic tmp+mv pattern
- Status line includes review-pending count when > 0
</verification>

<success_criteria>
The lifecycle state machine is fully operational: new sessions increment the counter, eligible candidates are promoted to review_pending, stale conventions decay, only active conventions (top 50 by confidence) are injected into CLAUDE.md, and all transitions are logged to changelog.jsonl. Existing conventions from Phases 2 and 4 are migrated seamlessly on first run.
</success_criteria>

<output>
After completion, create `.planning/phases/06-convention-lifecycle-review/06-01-SUMMARY.md`
</output>
