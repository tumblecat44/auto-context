---
phase: 06-convention-lifecycle-review
plan: 03
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - scripts/preserve-context.sh
  - hooks/hooks.json
  - scripts/inject-context.sh
autonomous: true
requirements:
  - PRSC-01
  - PRSC-02

must_haves:
  truths:
    - "PreCompact hook fires preserve-context.sh before context compaction"
    - "preserve-context.sh copies conventions.json, candidates.json, anti-patterns.json, and lifecycle.json to .auto-context/backup/"
    - "SessionStart restores from backup if primary data files are empty/corrupted but backup exists"
    - "PreCompact hook is type:command (only supported type for PreCompact)"
    - "Backup only happens if .auto-context/ directory exists"
    - "Restore cleans up backup directory after successful restoration"
  artifacts:
    - path: "scripts/preserve-context.sh"
      provides: "PreCompact backup handler"
      contains: "backup"
    - path: "hooks/hooks.json"
      provides: "PreCompact hook registration"
      contains: "PreCompact"
    - path: "scripts/inject-context.sh"
      provides: "PreCompact backup restore logic"
      contains: "BACKUP_DIR"
  key_links:
    - from: "hooks/hooks.json"
      to: "scripts/preserve-context.sh"
      via: "PreCompact command hook entry"
      pattern: "preserve-context\\.sh"
    - from: "scripts/preserve-context.sh"
      to: ".auto-context/backup/"
      via: "cp of critical JSON files"
      pattern: "backup"
    - from: "scripts/inject-context.sh"
      to: ".auto-context/backup/"
      via: "restore check on SessionStart"
      pattern: "BACKUP_DIR"
---

<objective>
Add PreCompact context preservation and SessionStart restore capability. This protects convention data from edge cases during context compaction and ensures the data store survives compaction events intact.

Purpose: Context compaction can occur at any time (manual or automatic). If the compaction happens during or after a state transition, data could be lost. The PreCompact backup provides a safety net, and the SessionStart restore handles the recovery.
Output: New preserve-context.sh script, updated hooks.json with PreCompact entry, restore logic documentation for inject-context.sh.
</objective>

<execution_context>
@/Users/dgsw67/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dgsw67/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-convention-lifecycle-review/06-RESEARCH.md
@.planning/phases/06-convention-lifecycle-review/06-01-SUMMARY.md
@hooks/hooks.json
@scripts/inject-context.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PreCompact backup script and register hook</name>
  <files>scripts/preserve-context.sh, hooks/hooks.json, scripts/inject-context.sh</files>
  <action>
**1. Create `scripts/preserve-context.sh`:**

```bash
#!/usr/bin/env bash
set -euo pipefail

# PreCompact hook: back up critical JSON data files before context compaction.
# PreCompact only supports type:"command" (no agent or prompt hooks).
# This hook cannot block compaction -- it just creates a safety backup.

INPUT=$(cat)
CWD=$(echo "$INPUT" | jq -r '.cwd')

STORE_DIR="${CWD}/.auto-context"
BACKUP_DIR="${STORE_DIR}/backup"

# Only back up if store exists
[ -d "$STORE_DIR" ] || exit 0

mkdir -p "$BACKUP_DIR"

# Back up critical data files (silently skip missing files)
for f in conventions.json candidates.json anti-patterns.json lifecycle.json; do
  [ -f "$STORE_DIR/$f" ] && cp "$STORE_DIR/$f" "$BACKUP_DIR/$f" 2>/dev/null || true
done

exit 0
```

The script:
- Reads hook input from stdin (required by all command hooks)
- Extracts cwd from hook input using jq
- Only acts if .auto-context/ directory exists
- Creates backup/ subdirectory
- Copies 4 critical JSON files (conventions, candidates, anti-patterns, lifecycle)
- Silently handles missing files with `|| true`
- Always exits 0 (cannot block compaction)

**2. Add PreCompact hook entry to `hooks/hooks.json`:**

Add a `PreCompact` entry to the hooks object. Place it between `Stop` and `SessionEnd` (logical lifecycle ordering: PreCompact fires before compaction, SessionEnd fires at end).

The new entry:
```json
"PreCompact": [
  {
    "hooks": [
      {
        "type": "command",
        "command": "${CLAUDE_PLUGIN_ROOT}/scripts/preserve-context.sh"
      }
    ]
  }
]
```

**Critical constraints:**
- PreCompact ONLY supports `type: "command"` (per research -- agent and prompt hooks silently fail on PreCompact)
- Preserve ALL existing hook entries (SessionStart, UserPromptSubmit, PostToolUse, PostToolUseFailure, Stop, SessionEnd)
- Use `${CLAUDE_PLUGIN_ROOT}` for the script path (consistent with all other hook entries)
- Validate resulting hooks.json with `jq .`

**3. Add restore logic to `scripts/inject-context.sh`:**

Add a restore check early in inject-context.sh, right after the data store initialization block (after the `[ -f ... ] || echo '[]'` lines) and BEFORE the lifecycle initialization.

The restore logic:
```bash
# --- Context Restoration from PreCompact Backup ---
BACKUP_DIR="${STORE_DIR}/backup"
if [ -d "$BACKUP_DIR" ]; then
  for f in conventions.json candidates.json anti-patterns.json lifecycle.json; do
    # Restore if primary file is empty/corrupted but backup exists and is valid
    if [ -f "$BACKUP_DIR/$f" ] && [ -s "$BACKUP_DIR/$f" ]; then
      if [ ! -s "$STORE_DIR/$f" ] || ! jq empty "$STORE_DIR/$f" 2>/dev/null; then
        cp "$BACKUP_DIR/$f" "$STORE_DIR/$f" 2>/dev/null || true
      fi
    fi
  done
  # Clean up backup directory after restore check
  rm -rf "$BACKUP_DIR" 2>/dev/null || true
fi
```

The restore logic:
- Checks if backup directory exists
- For each critical file: if the primary file is empty (`! -s`) OR invalid JSON (`! jq empty`), but the backup is valid, restore from backup
- After checking all files, remove the backup directory (it was a one-time safety net for the compaction event)
- Uses `|| true` for all operations to prevent failures from breaking the SessionStart pipeline
- `jq empty` returns 0 for valid JSON, non-zero for invalid -- this is a lightweight validation check

**Place this restore block BEFORE lifecycle initialization** so that restored lifecycle.json is available for the lifecycle pipeline.
  </action>
  <verify>
    <automated>bash -n scripts/preserve-context.sh && test -x scripts/preserve-context.sh 2>/dev/null && jq '.hooks.PreCompact[0].hooks[0].type' hooks/hooks.json 2>/dev/null | grep -q 'command' && jq '.hooks | keys | length' hooks/hooks.json | grep -q '7' && grep -q "backup" scripts/inject-context.sh && echo "PASS"</automated>
    <manual>Verify: preserve-context.sh backs up 4 JSON files to backup/ directory. hooks.json has 7 event types (SessionStart, UserPromptSubmit, PostToolUse, PostToolUseFailure, Stop, PreCompact, SessionEnd). PreCompact entry uses type:command. inject-context.sh has restore logic that checks backup dir, validates primary files with jq empty, restores if needed, cleans up backup dir.</manual>
  </verify>
  <done>preserve-context.sh creates backup of 4 critical JSON files during PreCompact. hooks.json registers PreCompact command hook. inject-context.sh includes restore logic that recovers from backup if primary files are empty/corrupted, then cleans up the backup directory. All files pass syntax validation.</done>
</task>

</tasks>

<verification>
- `bash -n scripts/preserve-context.sh` passes (valid bash)
- `chmod +x scripts/preserve-context.sh` -- script is executable
- `jq . hooks/hooks.json` validates (valid JSON)
- hooks.json has 7 hook events: SessionStart, UserPromptSubmit, PostToolUse, PostToolUseFailure, Stop, PreCompact, SessionEnd
- PreCompact entry: type=command, command references preserve-context.sh via ${CLAUDE_PLUGIN_ROOT}
- inject-context.sh restore block: checks backup dir, validates with jq empty, restores if needed, cleans up
- Restore logic is placed BEFORE lifecycle initialization in inject-context.sh
- All existing hooks preserved (no regressions)
</verification>

<success_criteria>
PreCompact hook fires before every context compaction and backs up the 4 critical JSON data files. On next SessionStart, if any primary file is empty or corrupted, data is automatically restored from the backup. The backup directory is cleaned up after the restore check. This provides a complete safety net for context compaction edge cases.
</success_criteria>

<output>
After completion, create `.planning/phases/06-convention-lifecycle-review/06-03-SUMMARY.md`
</output>
