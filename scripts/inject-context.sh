#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Read hook input from stdin (can only be read once)
INPUT=$(cat)
CWD=$(echo "$INPUT" | jq -r '.cwd')
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // "unknown"')

# Source library functions
source "${SCRIPT_DIR}/lib/markers.sh"
source "${SCRIPT_DIR}/lib/tokens.sh"
source "${SCRIPT_DIR}/lib/lifecycle.sh"

# --- Data Store Initialization ---
STORE_DIR="${CWD}/.auto-context"
mkdir -p "$STORE_DIR"

# Initialize JSON data files only if they don't exist (preserve existing data)
[ -f "$STORE_DIR/conventions.json" ]   || echo '[]' > "$STORE_DIR/conventions.json"
[ -f "$STORE_DIR/candidates.json" ]    || echo '[]' > "$STORE_DIR/candidates.json"
[ -f "$STORE_DIR/anti-patterns.json" ] || echo '[]' > "$STORE_DIR/anti-patterns.json"
[ -f "$STORE_DIR/config.json" ]        || cat > "$STORE_DIR/config.json" << 'CONF'
{
  "version": "0.1.0",
  "token_budget": 1000,
  "chars_per_token": 3.0
}
CONF

# --- Lifecycle Initialization ---
init_lifecycle "$STORE_DIR"

# Session log: JSONL format â€” one JSON object per line, O(1) append
# Create if missing but never overwrite (may have current session data)
[ -f "$STORE_DIR/session-log.jsonl" ] || touch "$STORE_DIR/session-log.jsonl"

# Safety net: clear stale session log from crashed/killed sessions
# If session-log.jsonl has entries with a different session_id, this is stale data
if [ -s "$STORE_DIR/session-log.jsonl" ]; then
  STALE_COUNT=$(jq -r --arg sid "$SESSION_ID" 'select(.session_id != $sid) | .session_id' "$STORE_DIR/session-log.jsonl" 2>/dev/null | head -1 | wc -c | tr -d ' ')
  if [ "$STALE_COUNT" -gt 1 ]; then
    : > "$STORE_DIR/session-log.jsonl"
  fi
fi

# Log session start event in JSONL format
echo "{\"ts\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"event\":\"session_start\",\"session_id\":\"${SESSION_ID}\",\"cwd\":\"${CWD}\"}" >> "$STORE_DIR/session-log.jsonl"

# --- Lifecycle Pipeline ---
# Increment session counter (only for new sessions, not resume/compact)
SESSION_COUNT=$(increment_session "$STORE_DIR" "$SESSION_ID")

# Migrate existing conventions/candidates that lack lifecycle fields
migrate_conventions "$STORE_DIR" "$SESSION_COUNT"

# Promote eligible candidates to review_pending
promote_candidates "$STORE_DIR"

# Decay stale conventions (not referenced in 5+ sessions)
decay_conventions "$STORE_DIR" "$SESSION_COUNT"

# --- Convention Injection into CLAUDE.md ---
CLAUDE_MD="${CWD}/CLAUDE.md"
TOKEN_BUDGET=$(jq -r '.token_budget // 1000' "$STORE_DIR/config.json" 2>/dev/null || echo 1000)

# Get active conventions filtered by stage and capped at 50
ACTIVE_CONVS=$(get_active_conventions "$STORE_DIR" 50)
CONV_COUNT=$(echo "$ACTIVE_CONVS" | jq 'length')

# Update last_referenced_session for all injected conventions
if [ "$CONV_COUNT" -gt 0 ]; then
  jq --argjson sc "$SESSION_COUNT" '
    [.[] | if .stage == "active" then .last_referenced_session = $sc else . end]
  ' "$STORE_DIR/conventions.json" > "$STORE_DIR/conventions.json.tmp" \
    && mv "$STORE_DIR/conventions.json.tmp" "$STORE_DIR/conventions.json"
fi

CAND_COUNT=$(jq 'length' "$STORE_DIR/candidates.json" 2>/dev/null || echo 0)
AP_COUNT=$(jq 'length' "$STORE_DIR/anti-patterns.json" 2>/dev/null || echo 0)

if [ "$CONV_COUNT" -gt 0 ]; then
  # Build markdown content from active conventions only
  CONTENT=$(echo "$ACTIVE_CONVS" | jq -r '
    "## Project Conventions (Auto-Context)\n\n" +
    (map("- " + .text) | join("\n")) +
    "\n\n_Auto-generated by auto-context plugin. Do not edit between markers._"
  ' 2>/dev/null || echo "")

  if [ -n "$CONTENT" ]; then
    CONTENT=$(enforce_budget "$CONTENT" "$TOKEN_BUDGET")
    ensure_markers "$CLAUDE_MD"
    inject_content "$CLAUDE_MD" "$CONTENT"
  fi
else
  if [ -f "$CLAUDE_MD" ]; then
    ensure_markers "$CLAUDE_MD"
    inject_content "$CLAUDE_MD" "_No conventions yet. Auto-Context is learning from your sessions._"
  fi
fi

# Count review-pending candidates for user awareness
REVIEW_COUNT=$(jq '[.[] | select(.stage == "review_pending")] | length' "$STORE_DIR/candidates.json" 2>/dev/null || echo 0)

# Build status line
STATUS_LINE="Auto-Context: ${CONV_COUNT} conventions active, ${CAND_COUNT} candidates pending"
[ "$REVIEW_COUNT" -gt 0 ] 2>/dev/null && STATUS_LINE="${STATUS_LINE} (${REVIEW_COUNT} ready for review)"
[ "$AP_COUNT" -gt 0 ] 2>/dev/null && STATUS_LINE="${STATUS_LINE}, ${AP_COUNT} anti-patterns"

# Output hook response with additionalContext for Claude
cat << EOF
{
  "hookSpecificOutput": {
    "hookEventName": "SessionStart",
    "additionalContext": "${STATUS_LINE}"
  }
}
EOF

exit 0
