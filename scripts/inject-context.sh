#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Read hook input from stdin (can only be read once)
INPUT=$(cat)
CWD=$(echo "$INPUT" | jq -r '.cwd')
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // "unknown"')

# Source library functions
source "${SCRIPT_DIR}/lib/markers.sh"
source "${SCRIPT_DIR}/lib/tokens.sh"

# --- Data Store Initialization ---
STORE_DIR="${CWD}/.auto-context"
mkdir -p "$STORE_DIR"

# Initialize JSON data files only if they don't exist (preserve existing data)
[ -f "$STORE_DIR/conventions.json" ]   || echo '[]' > "$STORE_DIR/conventions.json"
[ -f "$STORE_DIR/candidates.json" ]    || echo '[]' > "$STORE_DIR/candidates.json"
[ -f "$STORE_DIR/anti-patterns.json" ] || echo '[]' > "$STORE_DIR/anti-patterns.json"
[ -f "$STORE_DIR/config.json" ]        || cat > "$STORE_DIR/config.json" << 'CONF'
{
  "version": "0.1.0",
  "token_budget": 1000,
  "chars_per_token": 3.0
}
CONF

# Session log: JSONL format â€” one JSON object per line, O(1) append
# Create if missing but never overwrite (may have current session data)
[ -f "$STORE_DIR/session-log.jsonl" ] || touch "$STORE_DIR/session-log.jsonl"

# Safety net: clear stale session log from crashed/killed sessions
# If session-log.jsonl has entries with a different session_id, this is stale data
if [ -s "$STORE_DIR/session-log.jsonl" ]; then
  STALE_COUNT=$(jq -r --arg sid "$SESSION_ID" 'select(.session_id != $sid) | .session_id' "$STORE_DIR/session-log.jsonl" 2>/dev/null | head -1 | wc -c | tr -d ' ')
  if [ "$STALE_COUNT" -gt 1 ]; then
    : > "$STORE_DIR/session-log.jsonl"
  fi
fi

# Log session start event in JSONL format
echo "{\"ts\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"event\":\"session_start\",\"session_id\":\"${SESSION_ID}\",\"cwd\":\"${CWD}\"}" >> "$STORE_DIR/session-log.jsonl"

# --- Convention Injection into CLAUDE.md ---
CLAUDE_MD="${CWD}/CLAUDE.md"
CONVENTIONS_FILE="$STORE_DIR/conventions.json"
TOKEN_BUDGET=$(jq -r '.token_budget // 1000' "$STORE_DIR/config.json" 2>/dev/null || echo 1000)

# Read conventions and format as markdown
CONV_COUNT=$(jq 'length' "$CONVENTIONS_FILE" 2>/dev/null || echo 0)
CAND_COUNT=$(jq 'length' "$STORE_DIR/candidates.json" 2>/dev/null || echo 0)
AP_COUNT=$(jq 'length' "$STORE_DIR/anti-patterns.json" 2>/dev/null || echo 0)

if [ "$CONV_COUNT" -gt 0 ]; then
  # Build markdown content from conventions array
  # Each convention object has: { "text": "...", "confidence": N }
  CONTENT=$(jq -r '
    "## Project Conventions (Auto-Context)\n\n" +
    (map("- " + .text) | join("\n")) +
    "\n\n_Auto-generated by auto-context plugin. Do not edit between markers._"
  ' "$CONVENTIONS_FILE" 2>/dev/null || echo "")

  if [ -n "$CONTENT" ]; then
    # Enforce token budget
    CONTENT=$(enforce_budget "$CONTENT" "$TOKEN_BUDGET")

    # Ensure CLAUDE.md has valid markers (creates file if needed, repairs if corrupted)
    ensure_markers "$CLAUDE_MD"

    # Inject content between markers
    inject_content "$CLAUDE_MD" "$CONTENT"
  fi
else
  # No conventions yet -- ensure markers exist but inject empty placeholder
  # Only touch CLAUDE.md if it already exists (don't create empty file per research recommendation)
  if [ -f "$CLAUDE_MD" ]; then
    ensure_markers "$CLAUDE_MD"
    inject_content "$CLAUDE_MD" "_No conventions yet. Auto-Context is learning from your sessions._"
  fi
fi

# Build status line (anti-pattern count shown only when > 0)
STATUS_LINE="Auto-Context: ${CONV_COUNT} conventions active, ${CAND_COUNT} candidates pending"
[ "$AP_COUNT" -gt 0 ] 2>/dev/null && STATUS_LINE="${STATUS_LINE}, ${AP_COUNT} anti-patterns"

# Output hook response with additionalContext for Claude
cat << EOF
{
  "hookSpecificOutput": {
    "hookEventName": "SessionStart",
    "additionalContext": "${STATUS_LINE}"
  }
}
EOF

exit 0
